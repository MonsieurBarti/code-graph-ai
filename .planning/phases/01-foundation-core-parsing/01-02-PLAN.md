---
phase: 01-foundation-core-parsing
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/parser/mod.rs
  - src/parser/languages.rs
  - src/parser/symbols.rs
  - src/graph/mod.rs
  - src/graph/node.rs
  - src/graph/edge.rs
autonomous: true
requirements:
  - PARS-02

must_haves:
  truths:
    - "A .ts file parsed with tree-sitter produces a valid syntax tree"
    - "A .tsx file uses the TSX grammar (not the TS grammar)"
    - "A .js/.jsx file uses the JavaScript grammar"
    - "Functions, classes, interfaces, type aliases, enums are extracted as symbols"
    - "Exported const arrow functions are extracted as symbols"
    - "React components (functions returning JSX) are tagged as component kind"
    - "Interface properties and methods are tracked as child symbols"
    - "Class methods and object literal methods are extracted as symbols"
    - "Symbols are stored as nodes in a petgraph StableGraph"
  artifacts:
    - path: "src/parser/mod.rs"
      provides: "parse_file() orchestration dispatching to correct language"
      exports: ["parse_file"]
    - path: "src/parser/languages.rs"
      provides: "Language selection by file extension"
      exports: ["language_for_extension"]
    - path: "src/parser/symbols.rs"
      provides: "Tree-sitter queries for symbol extraction"
      exports: ["extract_symbols"]
    - path: "src/graph/mod.rs"
      provides: "CodeGraph struct wrapping StableGraph with lookup index"
      exports: ["CodeGraph"]
    - path: "src/graph/node.rs"
      provides: "GraphNode enum (File, Symbol) with all symbol kinds"
      exports: ["GraphNode", "SymbolKind"]
    - path: "src/graph/edge.rs"
      provides: "EdgeKind enum (Contains, Imports, Exports)"
      exports: ["EdgeKind"]
  key_links:
    - from: "src/parser/mod.rs"
      to: "src/parser/languages.rs"
      via: "language_for_extension() call before set_language()"
      pattern: "language_for_extension"
    - from: "src/parser/symbols.rs"
      to: "src/graph/node.rs"
      via: "Symbol extraction produces SymbolKind variants"
      pattern: "SymbolKind"
    - from: "src/graph/mod.rs"
      to: "src/graph/node.rs"
      via: "StableGraph parameterized with GraphNode"
      pattern: "StableGraph<GraphNode"
---

<objective>
Implement tree-sitter parser infrastructure and symbol extraction, along with the in-memory graph data structures.

Purpose: This is the core parsing engine. Without correct language selection, query compilation, and symbol extraction, the tool cannot fulfill PARS-02. The graph structures are needed by both this plan (to store symbols) and Plan 03 (to store imports/exports).
Output: Parser that extracts all symbol types from TS/JS files, graph data structures ready for the full pipeline.
</objective>

<execution_context>
@/Users/monsieurbarti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/monsieurbarti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-parsing/01-CONTEXT.md
@.planning/phases/01-foundation-core-parsing/01-RESEARCH.md
@.planning/phases/01-foundation-core-parsing/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Graph data structures (nodes, edges, CodeGraph)</name>
  <files>
    src/graph/mod.rs
    src/graph/node.rs
    src/graph/edge.rs
  </files>
  <action>
    Create the `src/graph/` module directory.

    **src/graph/node.rs** — Node types:
    - `SymbolKind` enum: `Function`, `Class`, `Interface`, `TypeAlias`, `Enum`, `Variable`, `Component`, `Method`, `Property`
      - `Component` = function that returns JSX (per user decision: tagged in addition to being a function)
      - `Method` = class method or object literal method (per user decision: maximum granularity)
      - `Property` = interface property/method signature (per user decision: child symbols)
    - `SymbolInfo` struct: `name: String`, `kind: SymbolKind`, `line: usize`, `col: usize`, `is_exported: bool`, `is_default: bool`
    - `FileInfo` struct: `path: PathBuf`, `language: String` (e.g., "typescript", "tsx", "javascript")
    - `GraphNode` enum: `File(FileInfo)`, `Symbol(SymbolInfo)`
    - Derive `Debug, Clone` on all types

    **src/graph/edge.rs** — Edge types:
    - `EdgeKind` enum: `Contains` (file -> symbol), `Imports { specifier: String }` (file -> file, the raw import path), `Exports { name: String, is_default: bool }` (file -> symbol), `ChildOf` (symbol -> symbol, for interface properties and class methods)
    - Derive `Debug, Clone`

    **src/graph/mod.rs** — CodeGraph wrapper:
    - `pub mod node;` and `pub mod edge;`
    - `CodeGraph` struct:
      - `graph: StableGraph<GraphNode, EdgeKind, Directed>`
      - `file_index: HashMap<PathBuf, NodeIndex>` (O(1) file lookup)
      - `symbol_index: HashMap<String, Vec<NodeIndex>>` (symbols by name for future queries)
    - `impl CodeGraph`:
      - `new() -> Self`
      - `add_file(path: PathBuf, language: &str) -> NodeIndex`
      - `add_symbol(file_idx: NodeIndex, info: SymbolInfo) -> NodeIndex` — adds symbol node + Contains edge from file
      - `add_child_symbol(parent_idx: NodeIndex, info: SymbolInfo) -> NodeIndex` — adds symbol node + ChildOf edge from parent
      - `file_count() -> usize` and `symbol_count() -> usize` (for summary)
      - `symbols_by_kind() -> HashMap<SymbolKind, usize>` (for the breakdown summary)

    Use `petgraph::stable_graph::{StableGraph, NodeIndex}` and `petgraph::Directed`.
  </action>
  <verify>
    `cargo build` succeeds. Create a quick smoke test in main.rs (temporary):
    ```rust
    let mut graph = CodeGraph::new();
    let f = graph.add_file(PathBuf::from("test.ts"), "typescript");
    let s = graph.add_symbol(f, SymbolInfo { name: "foo".into(), kind: SymbolKind::Function, line: 1, col: 0, is_exported: true, is_default: false });
    assert_eq!(graph.file_count(), 1);
    assert_eq!(graph.symbol_count(), 1);
    ```
    This can be a `#[cfg(test)] mod tests` block in graph/mod.rs.
  </verify>
  <done>
    Graph data structures compile. CodeGraph can add files, symbols, and child symbols. Lookup indexes are maintained. Symbol counting by kind works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tree-sitter parser infrastructure and symbol extraction</name>
  <files>
    src/parser/mod.rs
    src/parser/languages.rs
    src/parser/symbols.rs
  </files>
  <action>
    Create the `src/parser/` module directory.

    **src/parser/languages.rs** — Language selection:
    - `language_for_extension(ext: &str) -> Option<Language>` function
      - `"ts"` -> `tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into()`
      - `"tsx"` -> `tree_sitter_typescript::LANGUAGE_TSX.into()`
      - `"js"` | `"jsx"` -> `tree_sitter_javascript::LANGUAGE.into()`
      - `_` -> `None`
    - CRITICAL: `.ts` MUST use LANGUAGE_TYPESCRIPT, `.tsx` MUST use LANGUAGE_TSX — they are different grammars. Using TSX for .ts breaks angle-bracket casts. Using TS for .tsx breaks JSX.

    **src/parser/symbols.rs** — Symbol extraction:
    - Use `std::sync::OnceLock<Query>` for query caching — compile queries ONCE per language, NOT per file (performance pitfall from research)
    - Define separate query strings for TS and TSX (TSX needs JSX detection for React components; JS/JSX uses the JS grammar version)

    Symbol query must capture (per user decisions):
    1. `function_declaration` with `name: (identifier)` -> SymbolKind::Function
    2. `export_statement > lexical_declaration > variable_declarator` with `arrow_function` value -> SymbolKind::Function (exported arrow fns)
    3. Non-exported `lexical_declaration > variable_declarator` with `arrow_function` at top level -> SymbolKind::Function (top-level const arrow fns per user decision)
    4. `class_declaration` with `name: (type_identifier)` -> SymbolKind::Class
    5. `interface_declaration` with `name: (type_identifier)` -> SymbolKind::Interface
    6. `type_alias_declaration` with `name: (type_identifier)` -> SymbolKind::TypeAlias
    7. `enum_declaration` with `name: (identifier)` -> SymbolKind::Enum
    8. Exported `lexical_declaration > variable_declarator` WITHOUT arrow_function value -> SymbolKind::Variable

    **Child symbol extraction** (per user decision: interface properties + class methods):
    - After extracting an interface symbol, walk `interface_body` children for `property_signature` and `method_signature` -> SymbolKind::Property
    - After extracting a class symbol, walk `class_body` for `method_definition` -> SymbolKind::Method
    - Object literal methods: `method_definition` inside `object` -> SymbolKind::Method (when the object is exported or at top-level)

    **React component detection** (per user decision):
    - For TSX/JSX files: after extracting a function/arrow function, check if its body contains a `jsx_element` or `jsx_fragment` descendant
    - If found, tag the symbol as `SymbolKind::Component` (in ADDITION to being a function — store Component as the kind, the consumer knows it is also a function)
    - This is a heuristic — accept false positives per research recommendation

    **Export detection on symbols:**
    - Check if the symbol's parent or grandparent node is an `export_statement`
    - Set `is_exported: true` on the SymbolInfo
    - Check for `"default"` keyword presence for `is_default: true`

    `extract_symbols(tree: &Tree, source: &[u8], language: &Language, is_tsx: bool) -> Vec<(SymbolInfo, Vec<SymbolInfo>)>`
    Returns a vec of (parent_symbol, child_symbols) tuples.

    **src/parser/mod.rs** — Parse orchestration:
    - `pub mod languages;` and `pub mod symbols;`
    - `parse_file(path: &Path, source: &[u8]) -> anyhow::Result<ParseResult>` function:
      1. Get extension from path
      2. Call `language_for_extension(ext)` — return error if None
      3. Create `Parser::new()`, call `parser.set_language(&language)`
      4. Call `parser.parse(source, None)` — return error if None
      5. Call `extract_symbols(&tree, source, &language, is_tsx)`
      6. Return `ParseResult { symbols, tree }` (tree needed by Plan 03 for import/export extraction)
    - `ParseResult` struct: `symbols: Vec<(SymbolInfo, Vec<SymbolInfo>)>`, keep tree reference if needed

    Register modules in main.rs with `mod parser;` and `mod graph;`.
  </action>
  <verify>
    Write a `#[cfg(test)]` module in `parser/symbols.rs` with these test cases:

    1. Parse `export function hello() {}` -> extracts "hello" as Function, is_exported=true
    2. Parse `export const greet = () => {}` -> extracts "greet" as Function, is_exported=true
    3. Parse `class MyClass {}` -> extracts "MyClass" as Class
    4. Parse `interface IUser { name: string; getId(): number; }` -> extracts "IUser" as Interface with 2 child symbols (Property: "name", Property: "getId")
    5. Parse `type ID = string;` -> extracts "ID" as TypeAlias
    6. Parse `enum Color { Red, Blue }` -> extracts "Color" as Enum
    7. Parse TSX: `export const App = () => <div/>` -> extracts "App" as Component

    Run `cargo test`.
  </verify>
  <done>
    Parser correctly selects grammar by extension. Symbol extraction captures all 7 symbol types plus child symbols. Queries are compiled once (OnceLock). React components are detected in TSX/JSX files. Tests pass for all symbol types.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with all new modules
2. `cargo test` passes all symbol extraction tests
3. TS files use LANGUAGE_TYPESCRIPT, TSX files use LANGUAGE_TSX (verified by test)
4. All symbol types from PARS-02 are extracted: functions, classes, interfaces, type aliases, enums, exported variables
5. User-decision extras work: arrow functions, React components, interface children, class methods
</verification>

<success_criteria>
- Tree-sitter parses TS/TSX/JS/JSX files with correct grammar per extension
- All PARS-02 symbol types extracted with name, kind, line, col, export status
- Child symbols tracked for interfaces (properties) and classes (methods)
- React components detected via JSX heuristic in TSX/JSX files
- Queries compiled once per language (OnceLock pattern)
- Graph structures can store files, symbols, and edges
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-parsing/01-02-SUMMARY.md`
</output>
