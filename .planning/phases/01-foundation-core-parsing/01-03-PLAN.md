---
phase: 01-foundation-core-parsing
plan: 03
type: execute
wave: 3
depends_on:
  - 01-01
  - 01-02
files_modified:
  - src/parser/imports.rs
  - src/output.rs
  - src/main.rs
autonomous: true
requirements:
  - PARS-03
  - PARS-04

must_haves:
  truths:
    - "ESM `import { X } from './module'` statements are extracted with specifier and imported names"
    - "CJS `const X = require('./module')` calls are extracted as imports"
    - "Dynamic `import('./module')` with string literals are extracted as imports"
    - "Named exports `export { X, Y }` are extracted"
    - "Default exports `export default X` are extracted"
    - "Re-exports `export { X } from './module'` are extracted with source module"
    - "`code-graph index .` completes end-to-end: walks files, parses, extracts, builds graph, prints summary"
    - "Summary shows breakdown by symbol type (per user decision)"
    - "Silent by default, -v shows per-file output, --json outputs structured JSON"
    - "Malformed files are skipped with warning, indexing continues"
  artifacts:
    - path: "src/parser/imports.rs"
      provides: "Tree-sitter queries for import and export extraction"
      exports: ["extract_imports", "extract_exports"]
    - path: "src/output.rs"
      provides: "Summary formatting (human-readable and JSON)"
      exports: ["print_summary", "IndexStats"]
    - path: "src/main.rs"
      provides: "Full indexing pipeline orchestration"
      min_lines: 40
  key_links:
    - from: "src/main.rs"
      to: "src/parser/mod.rs"
      via: "parse_file() called for each discovered file"
      pattern: "parse_file"
    - from: "src/main.rs"
      to: "src/graph/mod.rs"
      via: "CodeGraph populated with parsed results"
      pattern: "graph\\.add_"
    - from: "src/main.rs"
      to: "src/output.rs"
      via: "print_summary called after indexing completes"
      pattern: "print_summary"
    - from: "src/parser/imports.rs"
      to: "src/graph/edge.rs"
      via: "Import/export data maps to EdgeKind variants"
      pattern: "EdgeKind"
---

<objective>
Implement import and export extraction from parsed syntax trees, then wire the complete indexing pipeline: walk -> parse -> extract -> graph -> summary.

Purpose: This completes Phase 1. Without import/export extraction (PARS-03, PARS-04), the graph has no edges. Without the pipeline, nothing runs end-to-end. This plan delivers the `code-graph index .` command that passes all Phase 1 success criteria.
Output: A complete `code-graph index .` command that walks, parses, extracts symbols/imports/exports, builds the graph, and prints a cargo-style summary.
</objective>

<execution_context>
@/Users/monsieurbarti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/monsieurbarti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-parsing/01-CONTEXT.md
@.planning/phases/01-foundation-core-parsing/01-RESEARCH.md
@.planning/phases/01-foundation-core-parsing/01-01-SUMMARY.md
@.planning/phases/01-foundation-core-parsing/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Import and export extraction queries</name>
  <files>
    src/parser/imports.rs
    src/parser/mod.rs
  </files>
  <action>
    **src/parser/imports.rs** — Import/export extraction:

    Use `OnceLock<Query>` for query caching (same pattern as symbols.rs).

    **Import extraction** — `extract_imports(tree: &Tree, source: &[u8], language: &Language) -> Vec<ImportInfo>`:

    `ImportInfo` struct: `kind: ImportKind`, `module_path: String`, `specifiers: Vec<ImportSpecifier>`
    `ImportKind` enum: `ESM`, `CJS`, `DynamicImport`
    `ImportSpecifier` struct: `name: String`, `alias: Option<String>`, `is_default: bool`, `is_namespace: bool`

    Query patterns (from research):
    1. **ESM static imports**: `(import_statement source: (string (string_fragment) @module_path)) @import`
       - Also capture import clause children: `import_specifier` (named), `identifier` (default), `namespace_import` (star)
       - Extract each specifier's `name` and optional `alias` field
    2. **CJS require**: `(call_expression function: (identifier) @fn arguments: (arguments (string (string_fragment) @module_path)))` with `#eq? @fn "require"`
       - Specifier: the variable name from the parent `variable_declarator` if present
    3. **Dynamic import**: `(call_expression function: (import) arguments: (arguments (string (string_fragment) @module_path))) @dynamic_import`
       - Only capture when argument is a string literal (not template literal or variable)

    **Export extraction** — `extract_exports(tree: &Tree, source: &[u8], language: &Language) -> Vec<ExportInfo>`:

    `ExportInfo` struct: `kind: ExportKind`, `names: Vec<String>`, `source: Option<String>` (for re-exports)
    `ExportKind` enum: `Named`, `Default`, `ReExport`, `ReExportAll`

    Query patterns (from research):
    1. **Named exports**: `(export_statement (export_clause (export_specifier name: (identifier) @export_name))) @named_export`
    2. **Default exports**: `(export_statement "default" [(identifier) (function_declaration) (class_declaration) (call_expression) (object) (array)] @default_export)`
       - Handle various default export value types
    3. **Re-exports**: `(export_statement (export_clause) source: (string (string_fragment) @source)) @reexport`
       - Extract both the specifier names and the source module path
    4. **Re-export all**: `(export_statement "*" source: (string (string_fragment) @source)) @reexport_all`
       - `export * from './module'` — captures the wildcard re-export

    Note: Inline exports (`export function foo()`, `export class Bar`) are already captured by the symbol extractor (symbols.rs) with `is_exported: true`. The export extractor focuses on standalone export statements.

    Register the module in `src/parser/mod.rs`: `pub mod imports;`

    Update `ParseResult` in `parser/mod.rs` to include:
    - `imports: Vec<ImportInfo>`
    - `exports: Vec<ExportInfo>`

    Call `extract_imports` and `extract_exports` inside `parse_file()` after symbol extraction.
  </action>
  <verify>
    Write `#[cfg(test)]` tests in `parser/imports.rs`:

    1. ESM: `import { useState, useEffect } from 'react'` -> 1 import, module_path="react", 2 named specifiers
    2. ESM default: `import React from 'react'` -> 1 import, 1 default specifier
    3. ESM namespace: `import * as path from 'path'` -> 1 import, 1 namespace specifier
    4. CJS: `const fs = require('fs')` -> 1 import, kind=CJS, module_path="fs"
    5. Dynamic: `const mod = await import('./lazy')` -> 1 import, kind=DynamicImport
    6. Named export: `export { foo, bar }` -> 1 export, kind=Named, 2 names
    7. Default export: `export default MyComponent` -> 1 export, kind=Default
    8. Re-export: `export { helper } from './utils'` -> 1 export, kind=ReExport, source="./utils"
    9. Re-export all: `export * from './types'` -> 1 export, kind=ReExportAll, source="./types"

    Run `cargo test`.
  </verify>
  <done>
    All 3 import types (ESM, CJS, dynamic) and all 4 export types (named, default, re-export, re-export-all) are extracted correctly. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Full indexing pipeline and summary output</name>
  <files>
    src/output.rs
    src/main.rs
  </files>
  <action>
    **src/output.rs** — Summary formatting:

    `IndexStats` struct (with `serde::Serialize` derive for --json):
    - `file_count: usize`
    - `functions: usize`
    - `classes: usize`
    - `interfaces: usize`
    - `type_aliases: usize`
    - `enums: usize`
    - `variables: usize`
    - `components: usize`
    - `methods: usize`
    - `properties: usize`
    - `imports: usize`
    - `exports: usize`
    - `skipped: usize`
    - `elapsed_secs: f64`

    `print_summary(stats: &IndexStats, json: bool)`:
    - If `json`: `serde_json::to_string_pretty(stats)` to stdout
    - If human-readable (default):
      ```
      Indexed 42 files in 0.15s
        240 functions, 85 classes, 120 interfaces, 30 types, 12 enums, 45 variables
        18 components, 340 methods, 520 properties
        892 imports, 456 exports
      ```
    - If `stats.skipped > 0`: add `  {N} files skipped (parse errors)` to stderr (per user decision: error counts only when files were actually skipped)
    - Style: cargo-like, clean, professional (per user specifics)

    **src/main.rs** — Full pipeline:

    In the `Index` command handler, orchestrate:

    1. **Start timer**: `let start = std::time::Instant::now();`
    2. **Walk files**: `let files = walker::walk_project(&path, &config, verbose)?;`
    3. **Create graph**: `let mut graph = graph::CodeGraph::new();`
    4. **Parse each file** (serial loop — parallel is Phase 6 per research):
       ```
       for file_path in &files {
           let source = match std::fs::read(file_path) {
               Ok(s) => s,
               Err(e) => {
                   if verbose { eprintln!("skip: {}: {}", file_path.display(), e); }
                   skipped += 1;
                   continue;
               }
           };
           match parser::parse_file(file_path, &source) {
               Ok(result) => {
                   let file_idx = graph.add_file(file_path.clone(), language_str);
                   // Add symbols + child symbols
                   for (symbol, children) in &result.symbols {
                       let sym_idx = graph.add_symbol(file_idx, symbol.clone());
                       for child in children {
                           graph.add_child_symbol(sym_idx, child.clone());
                       }
                   }
                   // Store import/export info in graph edges (file-level for now)
                   // Imports: add placeholder edges (actual resolution is Phase 2)
                   // Exports: tag symbols already marked is_exported
                   if verbose {
                       eprintln!("  {} symbols from {}", result.symbols.len(), file_path.display());
                   }
               }
               Err(e) => {
                   if verbose { eprintln!("skip: {}: {}", file_path.display(), e); }
                   skipped += 1;
               }
           }
       }
       ```
    5. **Compute stats**: Build `IndexStats` from `graph.symbols_by_kind()` + import/export counts + elapsed time
    6. **Print summary**: `output::print_summary(&stats, json);`

    **Error tolerance** (per user decisions):
    - Malformed files: skip, increment skipped counter, continue
    - Permission errors on read: skip, increment skipped counter, continue
    - Never fail the whole run due to individual file issues
    - Use `anyhow` for error context but catch and continue in the loop

    Register module in main.rs: `mod output;`
  </action>
  <verify>
    End-to-end test with the temp directory from Plan 01:
    ```bash
    # Create test project
    mkdir -p /tmp/cg-test/src
    cat > /tmp/cg-test/src/app.ts << 'TSEOF'
    import { useState } from 'react';
    import * as path from 'path';
    const fs = require('fs');

    export function hello(): void {}
    export const greet = () => {};
    export class UserService {}
    interface IUser { name: string; getId(): number; }
    type ID = string;
    enum Status { Active, Inactive }
    export default hello;
    export { UserService as US };
    TSEOF

    cat > /tmp/cg-test/src/comp.tsx << 'TSXEOF'
    export const App = () => <div>Hello</div>;
    export { App as default };
    TSXEOF

    # Run indexing
    cargo run -- index /tmp/cg-test

    # Expected output (approximately):
    # Indexed 2 files in 0.XXs
    #   2 functions, 1 classes, 1 interfaces, 1 types, 1 enums, 0 variables
    #   1 components, 0 methods, 2 properties
    #   3 imports, 3 exports

    # Verbose mode
    cargo run -- index /tmp/cg-test -v

    # JSON mode
    cargo run -- index /tmp/cg-test --json

    # Test error tolerance — create an unreadable file
    echo "this is not valid typescript {{{" > /tmp/cg-test/src/broken.ts
    cargo run -- index /tmp/cg-test
    # Should still complete, report skipped count if parse fails
    ```
  </verify>
  <done>
    `code-graph index .` runs end-to-end: discovers files, parses with tree-sitter, extracts symbols/imports/exports, builds the in-memory graph, and prints a cargo-style summary. All Phase 1 success criteria from the roadmap are met. Verbose and JSON modes work. Malformed files are skipped gracefully.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds
2. `cargo test` passes all import/export extraction tests
3. `code-graph index /tmp/cg-test` completes and prints symbol breakdown summary
4. `code-graph index /tmp/cg-test --json` outputs valid JSON with all stats
5. `code-graph index /tmp/cg-test -v` shows per-file details
6. Broken/malformed files are skipped without crashing the indexing run
7. ESM imports, CJS require, and dynamic imports are all extracted
8. Named exports, default exports, re-exports, and re-export-all are extracted
</verification>

<success_criteria>
- Full `code-graph index .` pipeline works end-to-end
- All PARS-03 import types extracted: ESM, CJS require, dynamic import
- All PARS-04 export types extracted: named, default, re-export
- Summary output matches user decision: symbol breakdown, elapsed time, cargo-style
- Error tolerance: malformed files skipped, indexing continues
- --verbose and --json flags work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-parsing/01-03-SUMMARY.md`
</output>
