---
phase: 04-mcp-integration
plan: 02
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - src/mcp/mod.rs
  - src/mcp/server.rs
  - src/mcp/params.rs
  - src/main.rs
autonomous: true
requirements:
  - INTG-01
  - INTG-02
  - INTG-03

must_haves:
  truths:
    - "Running code-graph mcp starts an MCP stdio server that responds to initialize and tools/list"
    - "Claude Code can discover 6 tools: find_symbol, find_references, get_impact, detect_circular, get_context, get_stats"
    - "Each MCP tool description is under 100 tokens (under 75 words)"
    - "A find_symbol call returns compact text lines (def name file:line kind) not JSON"
    - "Symbol-not-found returns an isError response with up to 3 fuzzy suggestions"
    - "Graph is built once (lazily on first tool call) and shared across all tool calls via Arc"
  artifacts:
    - path: "src/mcp/mod.rs"
      provides: "Module re-exports and run() entrypoint"
      exports: ["run"]
    - path: "src/mcp/server.rs"
      provides: "CodeGraphServer struct with #[tool_router] and #[tool_handler] for 6 tools"
      contains: "tool_router"
    - path: "src/mcp/params.rs"
      provides: "Typed param structs with Deserialize + JsonSchema for all 6 tools"
      contains: "FindSymbolParams"
  key_links:
    - from: "src/main.rs"
      to: "src/mcp/mod.rs"
      via: "mcp::run(path) call in Commands::Mcp arm"
      pattern: "mcp::run"
    - from: "src/mcp/server.rs"
      to: "src/query/output.rs"
      via: "format_*_to_string functions for tool responses"
      pattern: "format_find_to_string"
    - from: "src/mcp/server.rs"
      to: "src/query/find.rs"
      via: "find_symbol and match_symbols query functions"
      pattern: "query::find::find_symbol"
    - from: "src/mcp/server.rs"
      to: "src/main.rs"
      via: "build_graph function for graph construction"
      pattern: "build_graph"
---

<objective>
Implement the MCP stdio server with all 6 graph query tools, token-optimized responses, and fuzzy error suggestions.

Purpose: This is the core deliverable of Phase 4 — exposing the graph query engine to Claude Code via the MCP protocol. The server uses rmcp's `#[tool_router]` and `#[tool_handler]` proc macros to automatically generate tool schemas, handle JSON-RPC framing, and dispatch tool calls to the existing query modules. Responses use the compact text formatters (from Plan 01) to achieve the ~60% token savings target.

Output: A fully functional MCP stdio server that Claude Code can register and use to query dependency graphs.
</objective>

<execution_context>
@/Users/monsieurbarti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/monsieurbarti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mcp-integration/04-RESEARCH.md
@.planning/phases/04-mcp-integration/04-CONTEXT.md
@.planning/phases/04-mcp-integration/04-01-SUMMARY.md
@src/mcp/mod.rs
@src/query/output.rs
@src/query/find.rs
@src/query/refs.rs
@src/query/impact.rs
@src/query/circular.rs
@src/query/context.rs
@src/query/stats.rs
@src/main.rs
@src/graph/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP param structs and server with 6 tool handlers</name>
  <files>src/mcp/params.rs, src/mcp/server.rs, src/mcp/mod.rs</files>
  <action>
**src/mcp/params.rs** — Create typed parameter structs for all 6 MCP tools. Each struct derives `Deserialize` and `JsonSchema` (from schemars). Use `/// doc comment` on each field for automatic schema description generation by rmcp.

```rust
use serde::Deserialize;
use schemars::JsonSchema;

#[derive(Deserialize, JsonSchema)]
pub struct FindSymbolParams {
    /// Symbol name or regex pattern
    pub symbol: String,
    /// File/directory scope (relative to project root)
    pub path: Option<String>,
    /// Filter by kind: function, class, interface, type, enum, variable, component
    pub kind: Option<String>,
    /// Max results (default: 20)
    pub limit: Option<usize>,
    /// Project root path override
    pub project_path: Option<String>,
}

#[derive(Deserialize, JsonSchema)]
pub struct FindReferencesParams {
    /// Symbol name or regex pattern
    pub symbol: String,
    /// Max results (default: 30)
    pub limit: Option<usize>,
    /// Project root path override
    pub project_path: Option<String>,
}

#[derive(Deserialize, JsonSchema)]
pub struct GetImpactParams {
    /// Symbol name or regex pattern
    pub symbol: String,
    /// Max affected files (default: 50)
    pub limit: Option<usize>,
    /// Project root path override
    pub project_path: Option<String>,
}

#[derive(Deserialize, JsonSchema)]
pub struct DetectCircularParams {
    /// Project root path override
    pub project_path: Option<String>,
}

#[derive(Deserialize, JsonSchema)]
pub struct GetContextParams {
    /// Symbol name or regex pattern
    pub symbol: String,
    /// Project root path override
    pub project_path: Option<String>,
}

#[derive(Deserialize, JsonSchema)]
pub struct GetStatsParams {
    /// Project root path override
    pub project_path: Option<String>,
}
```

**src/mcp/server.rs** — Create `CodeGraphServer` struct with all 6 tool handlers.

Key implementation decisions:
- Store `default_project_root: Arc<PathBuf>` (from CLI arg or cwd)
- Store `graph_cache: Arc<tokio::sync::Mutex<HashMap<PathBuf, Arc<CodeGraph>>>>` for lazy graph building (keyed by project path to support project_path param)
- Derive `Clone` on `CodeGraphServer` (required by rmcp `#[tool_router]`)
- Store `tool_router: ToolRouter<Self>` field

The `build_graph` function from main.rs must be made accessible. Move the `build_graph` function from `main.rs` to be `pub fn build_graph(...)` at the top of main.rs (or better: keep it where it is and make it `pub(crate)` so the mcp module can call `crate::build_graph()`).

**Graph resolution per tool call:**
Create a helper method `async fn resolve_graph(&self, project_path_override: Option<&str>) -> Result<(Arc<CodeGraph>, PathBuf), String>` that:
1. Determines the effective project path: `project_path_override` > `self.default_project_root`
2. Checks `self.graph_cache` for an existing graph for that path
3. If not cached, calls `crate::build_graph(&path, false)` and wraps in `Arc`, stores in cache
4. Returns `(Arc<CodeGraph>, project_root_path)` or an error string
5. If graph is empty (0 files), returns error: `"No indexed files found at '{path}'. Run 'code-graph index <path>' first."`

**Tool descriptions (INTG-03 — must be under 100 tokens / ~75 words each):**
- `find_symbol`: `"Find symbol definitions by name or regex. Returns file:line locations and symbol kind."`
- `find_references`: `"Find all files and call sites that reference a symbol. Shows import and call edges."`
- `get_impact`: `"Get the blast radius of changing a symbol. Returns transitive dependent files."`
- `detect_circular`: `"Detect circular dependency cycles in the import graph. Returns file cycles."`
- `get_context`: `"360-degree view of a symbol: definition, references, callers, callees, type hierarchy."`
- `get_stats`: `"Project overview: file count, symbol breakdown by kind, import/resolution summary."`

**Tool handler implementations** (each follows the same pattern):
```rust
#[tool(description = "...")]
async fn find_symbol(&self, params: Parameters<FindSymbolParams>) -> Result<CallToolResult, McpError> {
    let p = params.0;
    let (graph, root) = self.resolve_graph(p.project_path.as_deref()).await
        .map_err(|e| internal_error(&e))?;

    let kind_filter: Vec<String> = p.kind
        .map(|k| k.split(',').map(|s| s.trim().to_string()).collect())
        .unwrap_or_default();

    let results = query::find::find_symbol(
        &graph, &p.symbol, false, &kind_filter,
        p.path.as_ref().map(Path::new), &root,
    ).map_err(|e| internal_error(&e.to_string()))?;

    if results.is_empty() {
        return Ok(not_found_result(&p.symbol, &suggest_similar(&graph, &p.symbol)));
    }

    let limit = p.limit.unwrap_or(20);
    let truncated = results.len() > limit;
    let limited = &results[..results.len().min(limit)];
    let output = query::output::format_find_to_string(limited, &root);
    // format_find_to_string already writes a summary header as line 1 (per CONTEXT.md).
    // If truncated, replace that header with a truncation-aware version so Claude
    // sees "showing N/M definitions (increase limit for more)" as the first line.
    let output = if truncated {
        let after_first_line = output.find('\n').map(|i| &output[i+1..]).unwrap_or("");
        format!("showing {}/{} definitions (increase limit for more)\n{}", limit, results.len(), after_first_line)
    } else {
        output
    };

    Ok(CallToolResult::success(vec![Content::text(output)]))
}
```

Apply the same pattern for all 6 tools, calling the appropriate `query::*` function and `format_*_to_string`. **For all tools with a `limit` param**, use the same truncation-header-replacement pattern shown above: when results are truncated, replace the formatter's first summary line with a truncation-aware header so Claude always sees count + truncation info as the very first line (per CONTEXT.md locked decision).

**For find_references:**
- Use `query::find::match_symbols()` to get NodeIndices
- Call `query::refs::find_refs()` with the indices
- Format with `format_refs_to_string`
- Default limit: 30
- When truncated, replace header with `"showing {limit}/{total} references (increase limit for more)"`

**For get_impact:**
- Use `query::find::match_symbols()` then `query::impact::blast_radius()`
- Format with `format_impact_to_string`
- Default limit: 50
- When truncated, replace header with `"showing {limit}/{total} affected files (increase limit for more)"`

**For detect_circular:**
- Call `query::circular::find_circular()`
- Format with `format_circular_to_string`
- No symbol param needed

**For get_context:**
- Use `query::find::match_symbols()` then `query::context::symbol_context()` for each match
- Format with `format_context_to_string`
- No explicit limit (context is per-symbol)

**For get_stats:**
- Call `query::stats::project_stats()`
- Format with `format_stats_to_string`

**Error handling:**
- Symbol not found: return `CallToolResult` with `is_error: Some(true)` and up to 3 fuzzy suggestions
- Create `fn suggest_similar(graph: &CodeGraph, query: &str) -> Vec<String>` that does simple prefix/substring matching on `graph.symbol_index` keys, returns up to 3 closest names
- Invalid regex: return `is_error: Some(true)` with the regex error message
- Graph build failure: return `is_error: Some(true)` with the error

Create helper functions:
```rust
fn not_found_result(symbol: &str, suggestions: &[String]) -> CallToolResult {
    let mut msg = format!("Symbol '{}' not found.", symbol);
    if !suggestions.is_empty() {
        msg.push_str(&format!(" Did you mean: {}?", suggestions.join(", ")));
    }
    CallToolResult {
        content: vec![Content::text(msg)],
        is_error: Some(true),
        ..Default::default()
    }
}

fn internal_error(msg: &str) -> McpError {
    McpError {
        code: ErrorCode::INTERNAL_ERROR,
        message: msg.into(),
        data: None,
    }
}
```

**ServerHandler implementation:**
```rust
#[tool_handler]
impl ServerHandler for CodeGraphServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            instructions: Some("code-graph: query TypeScript/JavaScript dependency graphs. Index with 'code-graph index <path>' first.".into()),
            capabilities: ServerCapabilities::builder().enable_tools().build(),
            ..Default::default()
        }
    }
}
```

**src/mcp/mod.rs** — Replace the placeholder with:
```rust
mod params;
mod server;

use std::path::PathBuf;
use rmcp::transport::stdio;

pub async fn run(project_root: PathBuf) -> anyhow::Result<()> {
    let service = server::CodeGraphServer::new(project_root);
    let server = rmcp::serve_server(service, stdio()).await?;
    server.waiting().await?;
    Ok(())
}
```
  </action>
  <verify>
    <automated>cd /workspace && cargo build 2>&1 | tail -5</automated>
    <manual>Verify the binary compiles with all 6 MCP tool handlers</manual>
  </verify>
  <done>src/mcp/ contains server.rs with 6 tool handlers, params.rs with 6 param structs, mod.rs with run() entrypoint. All compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Wire MCP server into main and verify end-to-end</name>
  <files>src/main.rs</files>
  <action>
1. In src/main.rs, update the `Commands::Mcp { path }` match arm to call the actual MCP server:
   ```rust
   Commands::Mcp { path } => {
       let project_root = path.unwrap_or_else(|| std::env::current_dir().expect("cannot determine current directory"));
       mcp::run(project_root).await?;
   }
   ```
   Note: Since main is now async (from Plan 01), the `.await` works directly.

2. Make `build_graph` function `pub(crate)` so `mcp::server` can call it:
   Change `fn build_graph(path: &PathBuf, verbose: bool) -> Result<CodeGraph>` to `pub(crate) fn build_graph(path: &PathBuf, verbose: bool) -> Result<CodeGraph>`.

3. Verify end-to-end with a JSON-RPC test:
   - Build the binary: `cargo build`
   - Run all existing tests: `cargo test`
   - Test MCP initialize handshake: pipe a JSON-RPC initialize request to stdin and verify the server responds with capabilities including tools. Use:
     ```bash
     echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"0.1"}}}' | timeout 5 ./target/debug/code-graph mcp . 2>/dev/null | head -1
     ```
   - The response should contain `"tools"` in its capabilities.
   - Test tools/list to verify all 6 tools are registered (if the initialize handshake works).

4. Verify tool descriptions are under 100 tokens each. Use the heuristic: 1 token ~ 4 chars. Count the character length of each description string and confirm each is under 400 characters (well within 100 tokens).
  </action>
  <verify>
    <automated>cd /workspace && cargo build && cargo test 2>&1 | tail -10</automated>
    <manual>Run `echo '...' | ./target/debug/code-graph mcp .` with JSON-RPC initialize to verify MCP handshake</manual>
  </verify>
  <done>Commands::Mcp arm calls mcp::run(), build_graph is pub(crate), cargo build + cargo test pass, MCP server responds to initialize handshake with tool capabilities</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with zero errors
2. `cargo test` — all existing tests pass (no regressions)
3. `./target/debug/code-graph mcp .` starts an MCP stdio server (blocks waiting for input)
4. JSON-RPC `initialize` request returns response with tools capability
5. JSON-RPC `tools/list` returns exactly 6 tools: find_symbol, find_references, get_impact, detect_circular, get_context, get_stats
6. Each tool description string is under 75 words / 400 characters
7. Calling find_symbol via JSON-RPC returns compact text lines (not JSON)
8. Calling find_symbol for a non-existent symbol returns isError=true with suggestions
</verification>

<success_criteria>
- MCP stdio server starts via `code-graph mcp [path]` and responds to JSON-RPC
- 6 tools discoverable via tools/list with concise descriptions (INTG-01, INTG-03)
- Tool responses use compact text format with ~60% fewer tokens than JSON (INTG-02)
- Symbol-not-found errors use isError flag with fuzzy suggestions
- Graph built once lazily on first tool call, shared across subsequent calls via Arc
- All existing CLI commands and tests continue to work
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-integration/04-02-SUMMARY.md`
</output>
