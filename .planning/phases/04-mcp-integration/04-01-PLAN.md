---
phase: 04-mcp-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/cli.rs
  - src/main.rs
  - src/query/output.rs
autonomous: true
requirements:
  - INTG-02

must_haves:
  truths:
    - "Output formatter functions can produce String output for MCP consumption without printing to stdout"
    - "All existing CLI subcommands continue to function after dependency and async-main changes"
    - "CLI has an Mcp subcommand variant that accepts an optional project path"
    - "code-graph mcp is visible in --help output and executes without panic"
  artifacts:
    - path: "Cargo.toml"
      provides: "rmcp + tokio + schemars dependencies"
      contains: "rmcp"
    - path: "src/cli.rs"
      provides: "Commands::Mcp variant"
      contains: "Mcp"
    - path: "src/main.rs"
      provides: "Async main with Mcp subcommand arm"
      contains: "tokio::main"
    - path: "src/query/output.rs"
      provides: "format_*_to_string sibling functions returning String"
      contains: "fn format_find_to_string"
  key_links:
    - from: "src/main.rs"
      to: "src/cli.rs"
      via: "Commands::Mcp match arm"
      pattern: "Commands::Mcp"
    - from: "src/query/output.rs"
      to: "src/query/find.rs"
      via: "FindResult type used in format_find_to_string"
      pattern: "format_find_to_string.*FindResult"
---

<objective>
Add MCP dependencies, Mcp CLI subcommand, and refactor output formatters to return String for MCP tool responses.

Purpose: Establish the infrastructure layer that Plan 02's MCP server module will build upon. The existing `println!`-based formatters cannot be used from MCP tool handlers (which must return String), so sibling `format_*_to_string` functions are needed. The async runtime (tokio) and MCP SDK (rmcp) must be available before the server can be built.

Output: Compilable project with new dependencies, async main, Mcp CLI variant, and String-returning formatters.
</objective>

<execution_context>
@/Users/monsieurbarti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/monsieurbarti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mcp-integration/04-RESEARCH.md
@src/query/output.rs
@src/cli.rs
@src/main.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and Mcp CLI subcommand</name>
  <files>Cargo.toml, src/cli.rs, src/main.rs</files>
  <action>
1. Add to Cargo.toml [dependencies]:
   - `rmcp = { version = "0.16", features = ["server", "transport-io", "macros"] }`
   - `tokio = { version = "1", features = ["full"] }`
   - `schemars = "1"`

2. Add to src/cli.rs Commands enum a new variant:
   ```rust
   /// Start an MCP stdio server exposing graph queries as tools for Claude Code.
   Mcp {
       /// Path to the project root (defaults to current directory if omitted).
       path: Option<PathBuf>,
   },
   ```

3. Convert src/main.rs:
   - Change `fn main() -> Result<()>` to `#[tokio::main] async fn main() -> Result<()>`
   - Add a match arm for `Commands::Mcp { path }` that for now just prints a placeholder message: `println!("MCP server not yet implemented");` (Plan 02 will replace this with the actual server startup).
   - All existing synchronous match arms remain unchanged (they work fine inside an async fn since they don't `.await` anything).

4. Add `mod mcp;` declaration to main.rs (the module will be created in Plan 02, but the declaration should be added now with a placeholder module file to avoid compile errors). Create `src/mcp/mod.rs` with just `// MCP server module — populated by Plan 02` as a comment and nothing else.

5. Verify: `cargo build` succeeds with no errors or warnings related to these changes.
  </action>
  <verify>
    <automated>cd /workspace && cargo build 2>&1 | tail -5</automated>
    <manual>Check that `cargo build` succeeds and the binary has the `mcp` subcommand in help output</manual>
  </verify>
  <done>Cargo.toml has rmcp/tokio/schemars, cli.rs has Commands::Mcp, main.rs is async with Mcp arm, project compiles cleanly</done>
</task>

<task type="auto">
  <name>Task 2: Refactor output formatters to return String</name>
  <files>src/query/output.rs</files>
  <action>
Add sibling `format_*_to_string` functions alongside each existing `format_*` function in src/query/output.rs. These new functions produce the same compact-format output as the existing `Compact` branch of each formatter, but write to a String buffer via `use std::fmt::Write` instead of `println!`. The existing `println!`-based functions remain untouched for CLI use.

**IMPORTANT (CONTEXT.md locked decision):** Every `format_*_to_string` function MUST write a summary header line (total count) as the FIRST line of the buffer, before any result lines. This lets Claude count-check results at a glance.

Add these 6 functions:

1. `pub fn format_find_to_string(results: &[FindResult], project_root: &Path) -> String` — summary header `{N} definitions found` first, then `def {name} {rel_path}:{line} {kind}` per result.

2. `pub fn format_stats_to_string(stats: &ProjectStats) -> String` — summary header `{N} files, {M} symbols` first, then lines for files, symbols, breakdown, imports.

3. `pub fn format_refs_to_string(results: &[RefResult], project_root: &Path) -> String` — summary header `{N} references found` first, then compact reference lines.

4. `pub fn format_impact_to_string(results: &[ImpactResult], project_root: &Path) -> String` — summary header `{N} affected files` first, then flat impact lines (no tree).

5. `pub fn format_circular_to_string(cycles: &[CircularDep], project_root: &Path) -> String` — summary header `{N} circular dependencies found` first, then cycle lines.

6. `pub fn format_context_to_string(contexts: &[SymbolContext], project_root: &Path) -> String` — summary header `{N} symbols` first, then labeled sections (`--- callers ---`, `--- callees ---`, etc.) per the CONTEXT.md decision.

Implementation pattern for each function (note: summary header line comes FIRST, per CONTEXT.md locked decision "always include a summary header line before results"):
```rust
pub fn format_find_to_string(results: &[FindResult], project_root: &Path) -> String {
    use std::fmt::Write;
    let mut buf = String::new();
    writeln!(buf, "{} definitions found", results.len()).unwrap();
    for r in results {
        let rel = r.file_path.strip_prefix(project_root).unwrap_or(&r.file_path);
        writeln!(buf, "def {} {}:{} {}", r.symbol_name, rel.display(), r.line, kind_to_str(&r.kind)).unwrap();
    }
    buf
}
```

For `format_context_to_string`, use the labeled section format per CONTEXT.md decision:
- `--- definitions ---` before definition lines
- `--- references ---` before reference lines
- `--- callers ---` before caller lines
- `--- callees ---` before callee lines
- `--- extends ---` before extends lines
- `--- implements ---` before implements lines
- `--- extended-by ---` before extended-by lines
- `--- implemented-by ---` before implemented-by lines
Only include sections that have at least one entry.

Note: The context_to_string variant uses labeled sections (per CONTEXT.md locked decision) which differs slightly from the CLI compact format. This is intentional — MCP context responses need clear section delimiters for Claude to parse.

Verify: `cargo build` succeeds and existing tests pass (the existing format_* functions are unchanged).
  </action>
  <verify>
    <automated>cd /workspace && cargo build && cargo test 2>&1 | tail -10</automated>
  </verify>
  <done>Six format_*_to_string functions exist in output.rs, all returning String with compact format, project compiles and all tests pass</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with zero errors
2. `cargo test` — all existing tests pass (no regressions)
3. `./target/debug/code-graph --help` shows `mcp` subcommand
4. `./target/debug/code-graph mcp` prints placeholder message (not yet wired to server)
5. The 6 new `format_*_to_string` functions exist in output.rs and return String
</verification>

<success_criteria>
- Project compiles with rmcp, tokio, schemars in dependency tree
- main.rs uses #[tokio::main] and all 8 CLI subcommands still work
- Commands::Mcp variant exists with optional path parameter
- 6 format_*_to_string functions available for MCP tool handlers to call
- All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-integration/04-01-SUMMARY.md`
</output>
