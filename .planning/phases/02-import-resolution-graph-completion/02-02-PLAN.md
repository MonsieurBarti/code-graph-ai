---
phase: 02-import-resolution-graph-completion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/parser/relationships.rs
  - src/parser/mod.rs
autonomous: true
requirements:
  - PARS-09

must_haves:
  truths:
    - "Direct function calls (foo()) in source code are extracted with the callee name"
    - "Method calls (obj.method()) are extracted with the method name"
    - "Class extends relationships are extracted with both class and parent names"
    - "Class implements relationships are extracted with both class and interface names"
    - "Interface extends relationships are extracted with both interface and parent names"
    - "Type annotation references (const x: SomeType) are extracted"
  artifacts:
    - path: "src/parser/relationships.rs"
      provides: "Tree-sitter queries and extraction functions for symbol relationships"
      exports: ["extract_relationships", "RelationshipInfo", "RelationshipKind"]
      min_lines: 100
    - path: "src/parser/mod.rs"
      provides: "Updated module with relationships submodule declaration"
      contains: "pub mod relationships"
  key_links:
    - from: "src/parser/relationships.rs"
      to: "tree-sitter"
      via: "OnceLock<Query> pattern matching Phase 1 conventions"
      pattern: "OnceLock"
    - from: "src/parser/relationships.rs"
      to: "src/parser/mod.rs"
      via: "pub mod declaration and re-export"
      pattern: "pub mod relationships"
---

<objective>
Create the tree-sitter query pass for extracting symbol-level relationships: function calls, method calls, class extends, class implements, interface extends, and type references.

Purpose: PARS-09 requires symbol-level relationship edges (calls, extends, implements). The tree-sitter extraction must be built before it can be wired into the graph. This plan is independent of the resolver (Plan 01) because it only queries the AST — it does not need resolved file paths.

Output: New src/parser/relationships.rs module with extraction functions and comprehensive unit tests.
</objective>

<execution_context>
@/Users/monsieurbarti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/monsieurbarti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-import-resolution-graph-completion/02-RESEARCH.md

@src/parser/mod.rs
@src/parser/imports.rs
@src/parser/symbols.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create relationship extraction module with tree-sitter queries</name>
  <files>
    src/parser/relationships.rs
    src/parser/mod.rs
  </files>
  <action>
    Create `src/parser/relationships.rs` following the exact same patterns established in Phase 1 for imports.rs and symbols.rs (OnceLock query caching, is_tsx parameter, StreamingIterator import).

    **Data types:**

    ```rust
    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum RelationshipKind {
        /// Direct function call: foo()
        Calls,
        /// Method call: obj.method() — stores the method name, not the object
        MethodCall,
        /// Class extends class: class Foo extends Bar
        Extends,
        /// Class implements interface: class Foo implements IBar
        Implements,
        /// Interface extends interface: interface IFoo extends IBar
        InterfaceExtends,
        /// Type reference in annotation: const x: SomeType, param: SomeType
        TypeReference,
    }

    #[derive(Debug, Clone)]
    pub struct RelationshipInfo {
        /// The name of the source symbol (caller, child class, etc.)
        /// None for top-level calls not inside a named function.
        pub from_name: Option<String>,
        /// The name of the target symbol (callee, parent class, interface, type)
        pub to_name: String,
        /// The kind of relationship
        pub kind: RelationshipKind,
        /// 1-based line number of the relationship site
        pub line: usize,
    }
    ```

    **Tree-sitter queries** — define as `const &str`, use three separate OnceLock sets (TS, TSX, JS) per query type, following the `is_tsx` dispatch pattern from imports.rs:

    1. **Calls query** (for direct calls and method calls):
    ```scheme
    ; Direct call: foo(...)
    (call_expression
      function: (identifier) @callee_name
      arguments: (arguments))

    ; Method call: obj.method(...)
    (call_expression
      function: (member_expression
        property: (property_identifier) @method_name)
      arguments: (arguments))
    ```

    2. **Inheritance query** (extends and implements):
    ```scheme
    ; class Foo extends Bar
    (class_declaration
      name: (type_identifier) @class_name
      (class_heritage
        (extends_clause
          value: (identifier) @extends_name)))

    ; class Foo implements IBar
    (class_declaration
      name: (type_identifier) @class_name
      (class_heritage
        (implements_clause
          (type_identifier) @implements_name)))

    ; interface IFoo extends IBar
    (interface_declaration
      name: (type_identifier) @iface_name
      (extends_type_clause
        (type_identifier) @parent_iface_name))
    ```

    Note on tree-sitter 0.26: The `extends_type_clause` node name for interface extends needs runtime validation. If the query fails to compile, try `extends_clause` instead (the grammar may use the same node for both class and interface extends). Log the fallback if needed.

    3. **Type reference query**:
    ```scheme
    ; Type annotation: const x: SomeType, param: SomeType
    (type_annotation
      (type_identifier) @type_ref)
    ```

    **Extraction function:**

    `pub fn extract_relationships(tree: &Tree, source: &[u8], language: &Language, is_tsx: bool) -> Vec<RelationshipInfo>`

    Follow the same pattern as `extract_imports`:
    - Get or initialize the appropriate OnceLock query for the language variant
    - Use `QueryCursor::new()` + `cursor.matches()` with `StreamingIterator`
    - For calls: build `RelationshipInfo` with `kind: Calls` for `@callee_name` captures and `kind: MethodCall` for `@method_name` captures. `from_name` can be None for now (context-free extraction — the caller resolution happens in Plan 03 during graph wiring).
    - For inheritance: use `@class_name`/`@iface_name` as `from_name`, `@extends_name`/`@implements_name`/`@parent_iface_name` as `to_name`.
    - For type refs: `from_name` is None (context-free), `to_name` is the type identifier text.

    **Deduplication:** De-duplicate results by `(to_name, line, kind)` tuple — same approach as symbols.rs uses `(name, row)`.

    **In src/parser/mod.rs:** Add `pub mod relationships;` declaration. Import `RelationshipInfo` and `extract_relationships`. Add `relationships: Vec<RelationshipInfo>` field to `ParseResult`. Call `extract_relationships` in `parse_file()` and store results in `ParseResult`.

    **Unit tests in relationships.rs** (inline `#[cfg(test)]` module):

    1. Test direct function call extraction: Parse `foo(); bar();` and verify two Calls relationships.
    2. Test method call extraction: Parse `obj.method(); this.render();` and verify MethodCall relationships.
    3. Test class extends: Parse `class Dog extends Animal {}` and verify Extends relationship with from_name="Dog", to_name="Animal".
    4. Test class implements: Parse `class UserService implements IService {}` and verify Implements relationship.
    5. Test interface extends: Parse `interface Admin extends User {}` and verify InterfaceExtends relationship.
    6. Test type reference: Parse `const x: MyType = {};` and verify TypeReference with to_name="MyType".
    7. Test combined: Parse a file with multiple relationship types and verify all are extracted correctly.

    For tests, use the same pattern as imports.rs tests: create a tree-sitter parser, parse a source string, call `extract_relationships`, assert on results. Use TypeScript language for tests (tree-sitter-typescript).
  </action>
  <verify>
    Run `cargo build` — must compile with the new module.
    Run `cargo test` — all existing tests plus new relationship tests pass.
    Run `cargo test -- relationships` to specifically verify relationship extraction.
    Run `cargo test -- parse_file` to verify ParseResult now includes relationships field.
  </verify>
  <done>
    `extract_relationships()` correctly extracts Calls, MethodCall, Extends, Implements, InterfaceExtends, and TypeReference from TypeScript/JavaScript source. ParseResult includes a `relationships` field populated by `parse_file()`. All unit tests pass including edge cases (no relationships in file, combined relationship types). The module follows the same OnceLock/StreamingIterator/is_tsx patterns as imports.rs.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles cleanly.
2. `cargo test -- relationships` passes all relationship extraction tests.
3. `cargo test` passes all tests (no regressions to Phase 1 functionality).
4. `extract_relationships` returns correct results for: function calls, method calls, class extends, class implements, interface extends, type annotations.
5. `ParseResult` struct has a `relationships: Vec<RelationshipInfo>` field populated by `parse_file()`.
</verification>

<success_criteria>
- All 6 relationship types are extracted by tree-sitter queries
- OnceLock caching pattern matches Phase 1 conventions (3 language variants)
- ParseResult includes relationships data populated during parse_file()
- Unit tests cover all relationship types with passing assertions
</success_criteria>

<output>
After completion, create `.planning/phases/02-import-resolution-graph-completion/02-02-SUMMARY.md`
</output>
