---
phase: 02-import-resolution-graph-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graph/edge.rs
  - src/graph/node.rs
  - src/graph/mod.rs
  - Cargo.toml
  - src/resolver/mod.rs
  - src/resolver/workspace.rs
  - src/resolver/file_resolver.rs
autonomous: true
requirements:
  - PARS-05
  - PARS-07
  - PARS-08

must_haves:
  truths:
    - "oxc_resolver resolves a relative import specifier to an absolute .ts file path"
    - "oxc_resolver resolves a tsconfig paths alias (e.g. @/utils) to the correct file"
    - "Workspace package names (npm, yarn, pnpm) map to their local source directories"
    - "Graph can store ExternalPackage and UnresolvedImport nodes alongside File and Symbol nodes"
    - "Graph can store ResolvedImport, Calls, Extends, Implements, BarrelReExportAll edges"
  artifacts:
    - path: "src/graph/edge.rs"
      provides: "Extended EdgeKind enum with Phase 2 edge variants"
      contains: "ResolvedImport"
    - path: "src/graph/node.rs"
      provides: "ExternalPackage and UnresolvedImport node types"
      contains: "ExternalPackage"
    - path: "src/graph/mod.rs"
      provides: "Helper methods for adding resolved edges and external/unresolved nodes"
      contains: "add_resolved_import"
    - path: "src/resolver/file_resolver.rs"
      provides: "oxc_resolver wrapper with TypeScript-aware configuration"
      contains: "build_resolver"
    - path: "src/resolver/workspace.rs"
      provides: "Workspace package map builder for npm/yarn/pnpm"
      contains: "discover_workspace_packages"
    - path: "src/resolver/mod.rs"
      provides: "Public resolver module re-exports"
      exports: ["build_resolver", "discover_workspace_packages"]
    - path: "Cargo.toml"
      provides: "oxc_resolver dependency"
      contains: "oxc_resolver"
  key_links:
    - from: "src/resolver/file_resolver.rs"
      to: "oxc_resolver"
      via: "Resolver::new with ResolveOptions"
      pattern: "Resolver::new"
    - from: "src/resolver/workspace.rs"
      to: "src/resolver/file_resolver.rs"
      via: "workspace aliases fed into ResolveOptions::alias"
      pattern: "AliasValue"
---

<objective>
Extend the graph data model with Phase 2 edge/node types, add oxc_resolver as a dependency, and build the resolver infrastructure module (workspace detection + oxc_resolver wrapper).

Purpose: This plan creates the foundational types and resolver infrastructure that all subsequent Phase 2 plans consume. Without the extended graph types, no new edges can be stored. Without the resolver, no imports can be resolved.

Output: Extended graph types in src/graph/, new src/resolver/ module with workspace detection and resolver construction, oxc_resolver in Cargo.toml.
</objective>

<execution_context>
@/Users/monsieurbarti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/monsieurbarti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-import-resolution-graph-completion/02-RESEARCH.md

@src/graph/edge.rs
@src/graph/node.rs
@src/graph/mod.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend graph types with Phase 2 edge and node variants</name>
  <files>
    src/graph/edge.rs
    src/graph/node.rs
    src/graph/mod.rs
  </files>
  <action>
    Extend the existing graph data model to support Phase 2 edges and nodes.

    **src/graph/edge.rs** — Add these variants to the `EdgeKind` enum (keep existing Contains, Imports, Exports, ChildOf):

    ```rust
    /// Resolved import edge: importing file -> resolved target file.
    /// specifier is the original raw import string from source.
    ResolvedImport { specifier: String },
    /// Symbol -> symbol: direct function/method call (foo() or obj.method()).
    Calls,
    /// Symbol -> symbol: class extends class, or interface extends interface.
    Extends,
    /// Symbol -> symbol: class implements interface.
    Implements,
    /// File -> file: barrel file re-exports everything from source (export * from './x').
    /// Resolved lazily at query time per user decision.
    BarrelReExportAll,
    ```

    **src/graph/node.rs** — Add `ExternalPackageInfo` struct and two new variants to `GraphNode`:

    ```rust
    /// External package node (node_modules dependency — internals not indexed).
    #[derive(Debug, Clone)]
    pub struct ExternalPackageInfo {
        pub name: String,
        pub version: Option<String>,
    }

    // Add to GraphNode enum:
    ExternalPackage(ExternalPackageInfo),
    UnresolvedImport { specifier: String, reason: String },
    ```

    **src/graph/mod.rs** — Add helper methods to `CodeGraph`:

    1. `add_resolved_import(&mut self, from: NodeIndex, to: NodeIndex, specifier: &str)` — Adds a `ResolvedImport` edge.
    2. `add_external_package(&mut self, from: NodeIndex, name: &str, specifier: &str) -> NodeIndex` — Creates an `ExternalPackage` node (or reuses if same package name already exists) and adds a `ResolvedImport` edge from the importing file. Maintain a `HashMap<String, NodeIndex>` for external package dedup (add as a field on `CodeGraph`).
    3. `add_unresolved_import(&mut self, from: NodeIndex, specifier: &str, reason: &str) -> NodeIndex` — Creates an `UnresolvedImport` node and edges from the file.
    4. `add_calls_edge(&mut self, caller: NodeIndex, callee: NodeIndex)` — Calls edge.
    5. `add_extends_edge(&mut self, child: NodeIndex, parent: NodeIndex)` — Extends edge.
    6. `add_implements_edge(&mut self, class_idx: NodeIndex, iface_idx: NodeIndex)` — Implements edge.
    7. `add_barrel_reexport_all(&mut self, barrel: NodeIndex, source: NodeIndex)` — BarrelReExportAll edge.

    Add an `external_index: HashMap<String, NodeIndex>` field to `CodeGraph` struct (initialized as empty in `new()`).

    Import `ExternalPackageInfo` in graph/mod.rs alongside existing imports.

    Add unit tests:
    - Test that `add_external_package` with the same package name twice returns the same NodeIndex.
    - Test that `add_unresolved_import` creates a node and edge.
    - Test that `add_resolved_import` creates an edge between two file nodes.
  </action>
  <verify>
    Run `cargo build` — the project must compile with the new types.
    Run `cargo test` — all existing tests plus new graph tests must pass.
  </verify>
  <done>
    EdgeKind has ResolvedImport, Calls, Extends, Implements, BarrelReExportAll variants. GraphNode has ExternalPackage and UnresolvedImport variants. CodeGraph has helper methods for adding all new edge/node types. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create resolver module with workspace detection and oxc_resolver wrapper</name>
  <files>
    Cargo.toml
    src/resolver/mod.rs
    src/resolver/workspace.rs
    src/resolver/file_resolver.rs
    src/main.rs
  </files>
  <action>
    Add `oxc_resolver = "3"` to `[dependencies]` in Cargo.toml. Do NOT add serde_yaml — implement minimal YAML line parsing for pnpm-workspace.yaml instead (the format is simple: `packages:\n  - 'glob'\n`).

    **src/resolver/mod.rs** — Module declarations and a public `resolve_all` stub:

    ```rust
    pub mod file_resolver;
    pub mod workspace;
    ```

    Re-export key items: `pub use file_resolver::{build_resolver, resolve_import, ResolutionOutcome};` and `pub use workspace::discover_workspace_packages;`.

    **src/resolver/workspace.rs** — Build a workspace package map:

    1. `discover_workspace_packages(root: &Path) -> HashMap<String, PathBuf>` — public function.
    2. Internally call `read_workspace_globs(root)` which:
       - Checks for `pnpm-workspace.yaml` at root. If found, parse it with `parse_pnpm_workspace_yaml()` — a minimal line parser that reads lines after `packages:` matching pattern `  - 'glob'` or `  - "glob"` or `  - glob` (strip quotes and leading whitespace/dash).
       - Else checks `package.json` at root for a `workspaces` JSON array (use serde_json).
       - Returns `Vec<String>` of glob patterns.
    3. For each glob pattern, expand using `glob::glob(&format!("{}/{}/package.json", root.display(), pattern))`.
    4. For each matched package.json, read it, extract `name`, and map to the package's `src/` dir if it exists, else the package root dir (per user decision: source, not dist).
    5. Return `HashMap<String, PathBuf>`.

    Add unit tests for `parse_pnpm_workspace_yaml()` with sample YAML content.

    **src/resolver/file_resolver.rs** — oxc_resolver wrapper:

    1. `build_resolver(project_root: &Path, workspace_aliases: Vec<(String, Vec<oxc_resolver::AliasValue>)>) -> oxc_resolver::Resolver` — Create resolver with:
       - `extensions`: `[".ts", ".tsx", ".mts", ".js", ".jsx", ".mjs", ".json", ".node"]` (TS first)
       - `extension_alias`: `.js` -> `[".ts", ".tsx", ".js"]`
       - `tsconfig`: If `tsconfig.json` exists at project_root, set `TsconfigOptions { config_file: root.join("tsconfig.json"), references: TsconfigReferences::Auto }`. If not found, `None`.
       - `alias`: workspace_aliases (converted from workspace map)
       - `condition_names`: `["node", "import"]`
       - Spread `..ResolveOptions::default()` for the rest.

    2. `resolve_import(resolver: &oxc_resolver::Resolver, from_file: &Path, specifier: &str) -> ResolutionOutcome` — Resolve a single import specifier.
       - On `Ok(resolution)` -> `ResolutionOutcome::Resolved(path)`.
       - On `Err` with builtin -> `ResolutionOutcome::BuiltinModule(name)`.
       - On other `Err` -> `ResolutionOutcome::Unresolved(reason_string)`.

    3. `pub enum ResolutionOutcome { Resolved(PathBuf), BuiltinModule(String), Unresolved(String) }`.

    4. `pub fn workspace_map_to_aliases(map: &HashMap<String, PathBuf>) -> Vec<(String, Vec<oxc_resolver::AliasValue>)>` — Convert workspace HashMap into the alias format oxc_resolver expects.

    Register the `resolver` module in **src/main.rs** by adding `mod resolver;` alongside the existing module declarations. Do NOT wire the resolution pipeline into the index command yet — that happens in Plan 03.

    Add a test in file_resolver.rs that constructs a resolver (with no tsconfig, empty aliases) and verifies it compiles and can be created without panicking.
  </action>
  <verify>
    Run `cargo build` — must compile with oxc_resolver integrated.
    Run `cargo test` — all tests pass including new workspace and resolver tests.
    Run `cargo test -- workspace` to specifically check workspace detection tests.
  </verify>
  <done>
    oxc_resolver is in Cargo.toml. Resolver module exists at src/resolver/ with workspace.rs and file_resolver.rs. `build_resolver()` creates an oxc_resolver::Resolver with correct TS config. `discover_workspace_packages()` detects npm/yarn/pnpm workspaces and maps package names to source dirs. All tests pass. `mod resolver` is declared in main.rs.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles cleanly with zero errors (new types + oxc_resolver dependency).
2. `cargo test` passes all tests (existing Phase 1 tests + new graph type tests + workspace tests + resolver construction test).
3. `src/graph/edge.rs` contains ResolvedImport, Calls, Extends, Implements, BarrelReExportAll variants.
4. `src/graph/node.rs` contains ExternalPackage and UnresolvedImport variants.
5. `src/resolver/workspace.rs` exports `discover_workspace_packages`.
6. `src/resolver/file_resolver.rs` exports `build_resolver` and `resolve_import`.
</verification>

<success_criteria>
- Graph data model supports all Phase 2 edge and node types
- oxc_resolver compiles and can construct a Resolver with TypeScript-aware options
- Workspace detection handles npm, yarn, and pnpm workspace formats
- All existing Phase 1 tests remain passing (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/02-import-resolution-graph-completion/02-01-SUMMARY.md`
</output>
