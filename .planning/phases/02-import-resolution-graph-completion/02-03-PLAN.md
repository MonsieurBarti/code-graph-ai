---
phase: 02-import-resolution-graph-completion
plan: 03
type: execute
wave: 2
depends_on:
  - "02-01"
  - "02-02"
files_modified:
  - src/resolver/mod.rs
  - src/resolver/barrel.rs
  - src/main.rs
  - src/output.rs
autonomous: true
requirements:
  - PARS-05
  - PARS-06
  - PARS-07
  - PARS-08
  - PARS-09

must_haves:
  truths:
    - "Every import in an indexed codebase is resolved to an absolute file path, an external package, or explicitly marked unresolved"
    - "Imports using tsconfig path aliases (@/utils) resolve to the correct file"
    - "Imports referencing workspace package names resolve to local source directories (not dist/node_modules)"
    - "Barrel file imports (through index.ts re-exports) chase to the original defining file for named re-exports"
    - "Wildcard re-exports (export * from) are recorded as BarrelReExportAll edges for lazy resolution"
    - "Symbol-level relationship edges (Calls, Extends, Implements) are added to the graph from parsed relationships"
    - "code-graph index . reports resolved/unresolved/external import counts in its output"
  artifacts:
    - path: "src/resolver/barrel.rs"
      provides: "Barrel chain resolution following re-export chains to original definers"
      exports: ["resolve_barrel_chains"]
      min_lines: 50
    - path: "src/resolver/mod.rs"
      provides: "resolve_all orchestrator function wiring workspace + resolver + barrel passes"
      exports: ["resolve_all"]
      min_lines: 40
    - path: "src/main.rs"
      provides: "Updated index pipeline calling resolve_all after parse loop"
      contains: "resolve_all"
    - path: "src/output.rs"
      provides: "Updated IndexStats with resolution metrics"
      contains: "resolved_imports"
  key_links:
    - from: "src/resolver/mod.rs"
      to: "src/resolver/file_resolver.rs"
      via: "build_resolver + resolve_import called for every import"
      pattern: "resolve_import"
    - from: "src/resolver/mod.rs"
      to: "src/resolver/workspace.rs"
      via: "discover_workspace_packages called before resolver construction"
      pattern: "discover_workspace_packages"
    - from: "src/resolver/mod.rs"
      to: "src/resolver/barrel.rs"
      via: "resolve_barrel_chains called after file-level resolution"
      pattern: "resolve_barrel_chains"
    - from: "src/resolver/mod.rs"
      to: "src/graph/mod.rs"
      via: "add_resolved_import, add_external_package, add_unresolved_import methods"
      pattern: "graph\\.add_"
    - from: "src/main.rs"
      to: "src/resolver/mod.rs"
      via: "resolve_all called after parse loop completes"
      pattern: "resolver::resolve_all"
---

<objective>
Wire the full resolution pipeline: resolve all imports to file paths using oxc_resolver, chase barrel re-export chains, add symbol-level relationship edges to the graph, and integrate everything into the `code-graph index` command.

Purpose: This is the integration plan that connects Plans 01 and 02 into a working pipeline. After this plan, `code-graph index .` produces a complete graph with file-level dependency edges and symbol-level relationship edges — fulfilling all Phase 2 requirements.

Output: Complete resolution pipeline in src/resolver/, updated main.rs with resolve step, updated output with resolution metrics.
</objective>

<execution_context>
@/Users/monsieurbarti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/monsieurbarti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-import-resolution-graph-completion/02-RESEARCH.md
@.planning/phases/02-import-resolution-graph-completion/02-01-SUMMARY.md
@.planning/phases/02-import-resolution-graph-completion/02-02-SUMMARY.md

@src/resolver/mod.rs
@src/resolver/file_resolver.rs
@src/resolver/workspace.rs
@src/parser/relationships.rs
@src/graph/mod.rs
@src/main.rs
@src/output.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement resolve_all orchestrator and barrel chain resolution</name>
  <files>
    src/resolver/barrel.rs
    src/resolver/mod.rs
  </files>
  <action>
    **src/resolver/barrel.rs** — Barrel chain resolution:

    Create `pub fn resolve_barrel_chains(graph: &mut CodeGraph, parse_results: &HashMap<PathBuf, ParseResult>)`.

    This function iterates all ResolvedImport edges in the graph. For each edge where the target file has re-exports (ExportKind::ReExport) matching the imported symbol names:
    1. Follow the re-export chain: look up the re-export's `source` module specifier, resolve it to a file (it should already be in the graph), check if THAT file also re-exports the symbol, and recurse.
    2. Use a `HashSet<PathBuf>` visited set to detect cycles (per user decision — mandatory cycle detection).
    3. When the chain terminates at a file that actually defines/exports the symbol (ExportKind::Named or ExportKind::Default), that's the original definer. No additional edge is needed at this stage — the file-level ResolvedImport edge already points correctly if the resolver resolved through the barrel. If the resolver stopped at the barrel (index.ts), note this for future query-time resolution.
    4. For `ExportKind::ReExportAll` (`export * from './x'`): add a `BarrelReExportAll` edge from the barrel file node to the source file node. Do NOT eagerly expand — per user decision, wildcard re-exports are resolved lazily at query time.

    **IMPORTANT:** The barrel resolution pass is a best-effort graph enrichment. If a re-export chain cannot be fully resolved (missing file, cycle), log at verbose level and continue. Never fail the whole pipeline for a single unresolvable barrel chain.

    **src/resolver/mod.rs** — The main orchestrator function:

    Update the module to add `pub mod barrel;` and create:

    ```rust
    pub fn resolve_all(
        graph: &mut CodeGraph,
        project_root: &Path,
        parse_results: &HashMap<PathBuf, ParseResult>,
        verbose: bool,
    ) -> ResolveStats
    ```

    `ResolveStats` is a new struct:
    ```rust
    pub struct ResolveStats {
        pub resolved: usize,
        pub unresolved: usize,
        pub external: usize,
        pub builtin: usize,
        pub relationships_added: usize,
    }
    ```

    The `resolve_all` function executes this pipeline:

    **Step 1: Build workspace map.**
    Call `discover_workspace_packages(project_root)`. Convert to aliases via `workspace_map_to_aliases()`. If verbose, log workspace packages found to stderr.

    **Step 2: Build resolver.**
    Call `build_resolver(project_root, aliases)`. Create ONE instance — reuse for all files (per anti-pattern warning in research).

    **Step 3: File-level resolution pass.**
    For each file in `parse_results`, for each `ImportInfo` in its imports:
    - Call `resolve_import(&resolver, file_path, &import.module_path)`.
    - Match on `ResolutionOutcome`:
      - `Resolved(target_path)`: Look up `target_path` in `graph.file_index`. If found, call `graph.add_resolved_import(from_file_idx, target_idx, &import.module_path)`. If target path is not in graph (e.g., JSON file, .node file), skip (it wasn't indexed). Increment `resolved` counter.
      - `BuiltinModule(name)`: Increment `builtin` counter. Add as unresolved with reason "builtin".
      - `Unresolved(reason)`: Call `graph.add_unresolved_import(from_file_idx, &import.module_path, &reason)`. Increment `unresolved` counter.
    - Classify external packages: if the specifier does not start with `.` or `/` and is not a tsconfig alias, AND resolution fails or resolves to a path containing `node_modules`, call `graph.add_external_package(from_file_idx, pkg_name, specifier)` where `pkg_name` is the specifier up to the first `/` (or the full specifier for unscoped packages, `@scope/name` for scoped packages). Increment `external` counter.

    **Step 4: Barrel chain pass.**
    Call `resolve_barrel_chains(graph, parse_results)`.

    **Step 5: Symbol relationship pass.**
    For each file in `parse_results`, for each `RelationshipInfo`:
    - For `Extends`, `Implements`, `InterfaceExtends`: look up `from_name` and `to_name` in `graph.symbol_index`. If both exist and from_name has exactly one match, add the appropriate edge. If to_name has multiple matches, prefer the one in the same file; if still ambiguous, add edge to all candidates (per research recommendation for ambiguous matches).
    - For `Calls` and `MethodCall`: look up `to_name` in `graph.symbol_index`. If exactly one match, add a `Calls` edge from the file node to the callee symbol node (since `from_name` may be None for top-level calls). If multiple matches, skip for now (cross-file call ambiguity — documented limitation per research Open Question 3).
    - For `TypeReference`: treat identically to Calls — look up in symbol_index, add edge if unambiguous.
    - Increment `relationships_added` counter for each edge added.

    Return `ResolveStats`.
  </action>
  <verify>
    Run `cargo build` — must compile.
    Run `cargo test` — all tests pass.
    Verify `resolve_all` signature accepts the correct parameters and returns `ResolveStats`.
  </verify>
  <done>
    `resolve_all()` orchestrates the full pipeline: workspace detection -> resolver construction -> file-level resolution -> barrel chain resolution -> symbol relationship wiring. `ResolveStats` tracks counts. Barrel chains use cycle detection. External packages are classified correctly. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate resolution pipeline into index command and update output</name>
  <files>
    src/main.rs
    src/output.rs
  </files>
  <action>
    **src/main.rs** — Wire `resolve_all` into the index command after the parse loop:

    1. The parse loop currently iterates files, parses them, and adds symbols to the graph. After this loop, add a resolution step.
    2. Collect parse results into a `HashMap<PathBuf, ParseResult>` during the parse loop (instead of discarding each ParseResult after extracting symbols). Modify the loop to store: `parse_results.insert(file_path.clone(), result);` after processing symbols.
    3. After the parse loop completes, call:
       ```rust
       let resolve_stats = resolver::resolve_all(&mut graph, &path, &parse_results, verbose);
       ```
    4. Pass `resolve_stats` metrics to the output stats.
    5. If verbose, print resolution summary to stderr:
       ```
       Resolved: {N} imports, {M} external, {K} unresolved, {J} builtins
       Relationships: {R} edges added
       ```

    **src/output.rs** — Extend `IndexStats` with resolution fields:

    Add these fields to `IndexStats`:
    ```rust
    pub resolved_imports: usize,
    pub unresolved_imports: usize,
    pub external_packages: usize,
    pub builtin_modules: usize,
    pub relationship_edges: usize,
    ```

    Update `print_summary()` to display these in both human-readable and JSON modes:
    - Human-readable: Add a "Resolution" section after the existing output:
      ```
         Resolved {N} imports ({M} external, {K} unresolved, {J} builtins)
         Added {R} relationship edges
      ```
    - JSON: The new fields are already included via `#[derive(Serialize)]`.

    Update the `IndexStats` construction in main.rs to populate the new fields from `resolve_stats`.

    Ensure `ParseResult` is stored by moving the `parse_results` HashMap above the loop and accumulating into it. The import/export counts can still be accumulated during the loop.
  </action>
  <verify>
    Run `cargo build` — must compile.
    Run `cargo test` — all tests pass.
    Run `cargo run -- index .` on the code-graph project itself (Rust files won't match .ts, so it should complete quickly with 0 files).
    Create a minimal test fixture: a temp directory with 2 .ts files where one imports from the other. Run `cargo run -- index /path/to/fixture` and verify the output shows resolved imports > 0.
    Test with `--json` flag and verify JSON output includes new resolution fields.
  </verify>
  <done>
    `code-graph index .` runs the full pipeline: walk -> parse -> resolve -> output. The output reports file counts, symbol counts, AND resolution metrics (resolved/unresolved/external/builtin imports, relationship edges). JSON output includes all new fields. ParseResult is retained during the parse loop for consumption by resolve_all. The resolution step executes after all files are parsed (two-pass architecture per research pattern).
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles cleanly.
2. `cargo test` passes all tests.
3. `cargo run -- index .` completes without errors (even on non-TS projects — gracefully handles 0 files).
4. On a TypeScript project with path aliases, the output shows resolved imports (not all unresolved).
5. On a monorepo with workspace packages, cross-package imports resolve to source directories.
6. JSON output (`--json`) includes resolved_imports, unresolved_imports, external_packages, builtin_modules, relationship_edges fields.
7. Barrel file imports through index.ts show BarrelReExportAll edges (visible in verbose mode).
</verification>

<success_criteria>
- Full resolution pipeline executes as part of `code-graph index .`
- Path alias imports resolve correctly (PARS-05)
- Barrel re-exports are chased to original definers for named re-exports; wildcards recorded as BarrelReExportAll (PARS-06)
- Workspace package imports resolve to local source dirs (PARS-07)
- Every import has a graph edge: ResolvedImport, ExternalPackage, or UnresolvedImport (PARS-08)
- Symbol-level relationships (Calls, Extends, Implements) are in the graph (PARS-09)
- Output metrics show resolution statistics
</success_criteria>

<output>
After completion, create `.planning/phases/02-import-resolution-graph-completion/02-03-SUMMARY.md`
</output>
