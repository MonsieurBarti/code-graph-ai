---
phase: 02-import-resolution-graph-completion
plan: "04"
type: execute
wave: 1
depends_on: ["02-03"]
files_modified:
  - src/resolver/barrel.rs
  - src/resolver/mod.rs
autonomous: true
requirements: [PARS-05, PARS-06, PARS-07, PARS-08, PARS-09]
gap_closure: true

must_haves:
  truths:
    - "An import { Foo } from './barrel' where barrel/index.ts has export { Foo } from './module' resolves to the defining file, not the barrel"
    - "Multi-level named re-export chains (barrel re-exports from another barrel) resolve to the final defining file"
    - "Circular named re-export chains terminate gracefully without infinite loops"
    - "Existing wildcard re-export (BarrelReExportAll) behavior is unchanged"
    - "All 53+ existing tests continue to pass"
  artifacts:
    - path: "src/resolver/barrel.rs"
      provides: "Named re-export chasing logic in resolve_named_reexport_chains()"
      contains: "ExportKind::ReExport"
    - path: "src/resolver/mod.rs"
      provides: "Updated resolve_all() Step 4 calling named re-export resolution"
      contains: "resolve_named_reexport_chains"
  key_links:
    - from: "src/resolver/barrel.rs"
      to: "parse_results HashMap"
      via: "ExportKind::ReExport iteration + source specifier lookup"
      pattern: "ExportKind::ReExport"
    - from: "src/resolver/mod.rs"
      to: "src/resolver/barrel.rs"
      via: "resolve_named_reexport_chains() called in Step 4 after resolve_barrel_chains()"
      pattern: "barrel::resolve_named_reexport_chains"
    - from: "src/resolver/barrel.rs"
      to: "src/graph/mod.rs"
      via: "graph.add_resolved_import() to wire direct edges bypassing barrel"
      pattern: "add_resolved_import"
---

<objective>
Close the named re-export barrel chasing gap identified in 02-VERIFICATION.md.

Purpose: PARS-06 requires that barrel file imports resolve to the *defining* file, not the barrel itself. Currently, `import { Foo } from './services'` where `services/index.ts` has `export { Foo } from './FooService'` produces a ResolvedImport edge to `index.ts` (the barrel) instead of `FooService.ts` (the defining file). Wildcard re-exports (`export * from`) are already handled via BarrelReExportAll edges. This plan adds named re-export chasing to close the gap.

Output: Updated `src/resolver/barrel.rs` with `resolve_named_reexport_chains()` function, updated `src/resolver/mod.rs` calling it, and new tests proving the behavior.
</objective>

<execution_context>
@/Users/monsieurbarti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/monsieurbarti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-import-resolution-graph-completion/02-03-SUMMARY.md
@.planning/phases/02-import-resolution-graph-completion/02-VERIFICATION.md

Key source files:
@src/resolver/barrel.rs
@src/resolver/mod.rs
@src/graph/mod.rs
@src/graph/edge.rs
@src/parser/imports.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement named re-export chain resolution in barrel.rs</name>
  <files>src/resolver/barrel.rs</files>
  <action>
Add a new public function `resolve_named_reexport_chains()` to `src/resolver/barrel.rs`. This function closes the gap where named re-exports (`export { Foo } from './module'`) are not chased to their defining file.

**Algorithm:**

1. Build a "named re-export map" from `parse_results`: for each file, collect its `ExportKind::ReExport` exports into a `HashMap<PathBuf, Vec<(Vec<String>, PathBuf)>>` mapping barrel_path -> vec of (exported_names, resolved_source_path). Use the existing `resolve_relative_specifier()` helper to resolve the source specifier to an absolute path.

2. Build a "reverse import map" from the graph: scan all `EdgeKind::ResolvedImport` edges. For each edge from file_A -> file_B, record (file_A_idx, file_B_path, specifier). This identifies which files import from which barrels.

3. For each `ResolvedImport` edge whose target is a file that has named re-exports: check if any of the *imported names* (from the ImportInfo in parse_results for the importing file) match one of the barrel's re-exported names. If so, chase the re-export chain to find the defining file:
   - Look up the barrel's `ExportKind::ReExport` entries. For each matching name, follow the `source` specifier to the next file.
   - If that next file also re-exports the name (another barrel), continue chasing. Use a `HashSet<PathBuf>` visited set to detect cycles.
   - When a file is found that does NOT re-export the name (it defines it), that is the defining file.

4. For each resolved chain, add a NEW `ResolvedImport` edge from the importing file directly to the defining file. Do NOT remove the existing edge to the barrel (it is still a valid file-level dependency). The new edge provides the "chase-through" resolution that PARS-06 requires.

5. Return a count of edges added for stats tracking.

**Important implementation details:**
- Reuse the existing `resolve_relative_specifier()` function already in barrel.rs for specifier-to-path resolution.
- The `ImportInfo.specifiers` vec on each import contains `ImportSpecifier` structs with a `name` field (and optionally `alias` for `import { original as alias }` — use the `alias` field as the original exported name when present, otherwise use `name`).
- Only process relative specifier imports (starting with `.` or `..`). External package imports cannot be barrel files in our indexed codebase.
- Handle the edge case where a barrel re-exports a name that it also defines locally (the barrel IS the defining file) — no additional edge needed in that case.
- Use `petgraph::visit::EdgeRef` trait (already imported in barrel.rs tests) — import it at the module level.

**Add 4 unit tests:**
1. `test_named_reexport_adds_direct_edge` — barrel `index.ts` has `export { Foo } from './foo'`, importing file has `import { Foo } from '.'`. After resolution, a direct ResolvedImport edge exists from importing file to `foo.ts`.
2. `test_named_reexport_multi_level_chain` — barrel re-exports from another barrel which re-exports from the defining file. Verify the chain resolves to the final defining file.
3. `test_named_reexport_cycle_detection` — two barrels re-export the same name from each other. Verify no infinite loop and no crash.
4. `test_named_reexport_no_edge_when_name_not_found` — barrel has `export { Foo } from './foo'` but importing file imports `{ Bar }` from the barrel. No additional edge should be added.
  </action>
  <verify>
`cargo test -p code-graph` passes (all existing 53+ tests plus 4 new tests).
`cargo build` compiles cleanly (warnings acceptable for pre-existing dead code only; no new warnings from barrel.rs).
  </verify>
  <done>
`resolve_named_reexport_chains()` function exists in barrel.rs, correctly chases ExportKind::ReExport entries to defining files, adds direct ResolvedImport edges, handles cycles and multi-level chains, and all 4 new tests pass alongside existing tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire named re-export resolution into resolve_all pipeline and verify end-to-end</name>
  <files>src/resolver/mod.rs</files>
  <action>
Update `resolve_all()` in `src/resolver/mod.rs` to call the new `resolve_named_reexport_chains()` function.

**Changes to resolve_all():**

1. In Step 4 (after the existing `barrel::resolve_barrel_chains()` call), add a new call:
   ```
   let named_reexport_edges = barrel::resolve_named_reexport_chains(graph, parse_results, verbose);
   ```

2. Add a `named_reexport_edges: usize` field to `ResolveStats` struct. Initialize to 0 in `Default`. Set it from the return value of `resolve_named_reexport_chains()`.

3. If `verbose`, log the count: `eprintln!("  Named re-export edges added: {}", named_reexport_edges);`

**End-to-end verification:**

After making the changes, create a temporary test fixture directory to verify the full pipeline:

```
/tmp/barrel-test/
  tsconfig.json          — { "compilerOptions": { "target": "es2020", "module": "esnext" } }
  src/
    app.ts               — import { UserService } from './services';
    services/
      index.ts           — export { UserService } from './UserService';
      UserService.ts     — export class UserService { }
```

Run `cargo run -- index /tmp/barrel-test -v` and verify:
- The verbose output shows a named re-export edge being added from `app.ts` to `UserService.ts`
- `resolved_imports` count includes the direct edge
- No errors or panics

Note: The `ResolveStats.named_reexport_edges` field does NOT need to appear in `src/output.rs` IndexStats or user-facing output — it is internal diagnostic information. The existing `resolved_imports` count already captures these edges. Only add the field to `ResolveStats` for verbose/debug purposes.
  </action>
  <verify>
`cargo test -p code-graph` passes (all tests).
`cargo build` compiles cleanly.
`cargo run -- index /tmp/barrel-test -v` shows named re-export edge from app.ts to UserService.ts (not just to index.ts).
  </verify>
  <done>
resolve_all() calls resolve_named_reexport_chains() in Step 4. ResolveStats tracks named re-export edge count. End-to-end test with barrel fixture confirms `import { UserService } from './services'` resolves through the barrel to `UserService.ts`. The gap identified in 02-VERIFICATION.md (Success Criterion 2 / PARS-06) is closed.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` — clean compile (no new warnings)
2. `cargo test` — all tests pass (53 existing + 4 new = 57+)
3. Manual barrel fixture test: `import { Foo } from './barrel'` where barrel has `export { Foo } from './module'` produces a ResolvedImport edge to `module.ts` (not just `barrel/index.ts`)
4. Multi-level chain test: barrel -> barrel -> defining file resolves correctly
5. Cycle test: circular re-exports do not hang or crash
</verification>

<success_criteria>
- Named re-export imports resolve to the defining file, not the barrel
- All existing behavior (wildcard BarrelReExportAll, file-level resolution, symbol relationships) is unchanged
- All tests pass (existing + new)
- PARS-06 / ROADMAP Success Criterion 2 is satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-import-resolution-graph-completion/02-04-SUMMARY.md`
</output>
