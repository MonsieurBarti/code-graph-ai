---
phase: 05-watch-mode-persistence
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/watcher/mod.rs
  - src/watcher/event.rs
  - src/watcher/incremental.rs
  - Cargo.toml
  - src/main.rs
autonomous: true
requirements: [INTG-04, INTG-05]

must_haves:
  truths:
    - "File watcher receives filesystem events and debounces them at ~75ms"
    - "A single-file change triggers remove + re-parse + re-resolve scoped to that file and direct dependents"
    - "File deletion removes the file from the graph and marks imports pointing to it as unresolved"
    - "New file creation parses it and checks if existing unresolved imports now resolve to it"
    - "Config file changes (tsconfig.json, package.json) trigger full re-index"
    - "node_modules and .code-graph paths are filtered out of watcher events"
    - "Watcher respects .gitignore rules from initial indexing — ignored paths (dist/, build/, etc.) do not trigger re-index"
  artifacts:
    - path: "src/watcher/mod.rs"
      provides: "WatcherHandle, start_watcher function, event loop"
      contains: "start_watcher"
    - path: "src/watcher/event.rs"
      provides: "WatchEvent enum (Modified, Created, Deleted, ConfigChanged)"
      contains: "WatchEvent"
    - path: "src/watcher/incremental.rs"
      provides: "handle_file_event, remove_file_from_graph integration, incremental resolve"
      contains: "handle_file_event"
  key_links:
    - from: "src/watcher/mod.rs"
      to: "notify-debouncer-mini"
      via: "new_debouncer with 75ms timeout, std::sync::mpsc bridge to tokio"
      pattern: "new_debouncer"
    - from: "src/watcher/incremental.rs"
      to: "src/graph/mod.rs"
      via: "calls remove_file_from_graph + add_file + add_symbol for incremental update"
      pattern: "remove_file_from_graph"
    - from: "src/watcher/incremental.rs"
      to: "src/resolver/mod.rs"
      via: "scoped resolve for changed file's imports"
      pattern: "resolve_import"
---

<objective>
Implement the file watcher and incremental re-index pipeline.

Purpose: This enables automatic graph updates when files change (INTG-04) with sub-100ms single-file re-indexing (INTG-05). The watcher uses notify + debouncer-mini with a sync-to-tokio bridge. The incremental pipeline surgically updates only the changed file and its direct dependents.

Output: Watcher module with event loop, incremental re-index functions, WatcherHandle for lifetime management.
</objective>

<execution_context>
@/Users/monsieurbarti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/monsieurbarti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-watch-mode-persistence/05-RESEARCH.md
@.planning/phases/05-watch-mode-persistence/05-01-SUMMARY.md
@src/graph/mod.rs
@src/resolver/mod.rs
@src/resolver/file_resolver.rs
@src/parser/mod.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Watcher infrastructure with notify-debouncer-mini</name>
  <files>
    Cargo.toml
    src/watcher/mod.rs
    src/watcher/event.rs
    src/main.rs
  </files>
  <action>
    **Cargo.toml:** Add dependencies:
    - `notify = "8"`
    - `notify-debouncer-mini = "0.7"`

    **src/main.rs:** Add `mod watcher;` declaration.

    **src/watcher/event.rs:**
    Define the internal event type:
    ```rust
    use std::path::PathBuf;

    /// Internal watch event types after classification.
    #[derive(Debug, Clone)]
    pub enum WatchEvent {
        /// A source file was modified (content changed).
        Modified(PathBuf),
        /// A new source file was created.
        Created(PathBuf),
        /// A source file was deleted.
        Deleted(PathBuf),
        /// A config file changed (tsconfig.json, package.json) — triggers full re-index.
        ConfigChanged,
    }
    ```

    **src/watcher/mod.rs:**
    Implement the watcher using the sync-to-tokio bridge pattern from research.

    **IMPORTANT — .gitignore compliance (locked CONTEXT.md decision):**
    The watcher MUST respect the same .gitignore rules used during initial indexing (single source of truth). Build an `ignore::gitignore::Gitignore` matcher from the project root's `.gitignore` file and pass it into the bridge task for use in `classify_event`. This ensures paths like `dist/`, `build/`, `*.generated.ts`, or any other .gitignore'd patterns are excluded from watcher events, matching the behavior of `walker::walk_project` which uses `ignore::WalkBuilder` with `standard_filters(true)`.

    ```rust
    pub mod event;
    pub mod incremental;

    use std::path::{Path, PathBuf};
    use std::sync::Arc;
    use std::time::Duration;

    use ignore::gitignore::{Gitignore, GitignoreBuilder};
    use notify_debouncer_mini::{new_debouncer, DebounceEventResult};
    use notify::RecursiveMode;
    use tokio::sync::mpsc as tokio_mpsc;
    use tokio::task::JoinHandle;

    use event::WatchEvent;

    /// Handle to a running watcher. Keeps the debouncer alive (dropping stops watching).
    pub struct WatcherHandle {
        /// Keep alive: dropping the debouncer stops the OS watcher.
        _debouncer: notify_debouncer_mini::Debouncer<notify::RecommendedWatcher>,
        /// The bridge task forwarding events from std channel to tokio channel.
        _bridge_task: JoinHandle<()>,
    }

    /// File extensions we care about for incremental re-index.
    const SOURCE_EXTENSIONS: &[&str] = &["ts", "tsx", "js", "jsx"];

    /// Config file basenames that trigger full re-index.
    const CONFIG_FILES: &[&str] = &["tsconfig.json", "package.json", "pnpm-workspace.yaml"];

    /// Build a Gitignore matcher from the project root's .gitignore file.
    /// This is the same source of truth used by `walker::walk_project` via `ignore::WalkBuilder`.
    /// If no .gitignore exists, returns an empty matcher that matches nothing.
    fn build_gitignore_matcher(project_root: &Path) -> Gitignore {
        let mut builder = GitignoreBuilder::new(project_root);
        let gitignore_path = project_root.join(".gitignore");
        if gitignore_path.exists() {
            let _ = builder.add(&gitignore_path);
        }
        // Also check nested .gitignore files are handled — the ignore crate's
        // GitignoreBuilder handles the root .gitignore. For nested dirs, the
        // walker handles them during walk. For the watcher, the root .gitignore
        // covers the vast majority of cases (dist/, build/, *.generated.ts, etc.).
        builder.build().unwrap_or_else(|_| Gitignore::empty())
    }

    /// Start a debounced file watcher on `watch_root`.
    ///
    /// Returns a `WatcherHandle` (must be kept alive) and a tokio mpsc receiver
    /// that yields classified `WatchEvent`s.
    ///
    /// The watcher:
    /// - Debounces at 75ms (within the locked 50-100ms range)
    /// - Filters out node_modules and .code-graph paths (hardcoded)
    /// - Filters out .gitignore'd paths (same rules as initial indexing)
    /// - Classifies events into Modified/Created/Deleted/ConfigChanged
    pub fn start_watcher(
        watch_root: &Path,
    ) -> anyhow::Result<(WatcherHandle, tokio_mpsc::Receiver<WatchEvent>)> {
        let (std_tx, std_rx) = std::sync::mpsc::channel::<DebounceEventResult>();

        // Create debounced watcher with 75ms debounce
        let mut debouncer = new_debouncer(Duration::from_millis(75), move |res| {
            let _ = std_tx.send(res);
        })?;
        debouncer.watcher().watch(watch_root, RecursiveMode::Recursive)?;

        // Build gitignore matcher — same rules as walker::walk_project
        let gitignore = build_gitignore_matcher(watch_root);

        // Tokio channel for classified events
        let (tokio_tx, tokio_rx) = tokio_mpsc::channel::<WatchEvent>(256);

        // Bridge: spawn_blocking to receive from std channel, classify, forward to tokio
        let root = watch_root.to_path_buf();
        let bridge_task = tokio::task::spawn_blocking(move || {
            while let Ok(result) = std_rx.recv() {
                match result {
                    Ok(events) => {
                        for debounced_event in events {
                            let path = debounced_event.path;
                            if let Some(watch_event) = classify_event(&path, &root, &gitignore) {
                                if tokio_tx.blocking_send(watch_event).is_err() {
                                    return; // receiver dropped, shutdown
                                }
                            }
                        }
                    }
                    Err(errs) => {
                        for err in errs {
                            eprintln!("[watcher] error: {:?}", err);
                        }
                    }
                }
            }
        });

        Ok((
            WatcherHandle {
                _debouncer: debouncer,
                _bridge_task: bridge_task,
            },
            tokio_rx,
        ))
    }

    /// Classify a filesystem event path into a WatchEvent, or None if it should be ignored.
    ///
    /// Filtering order:
    /// 1. Hardcoded exclusions: node_modules, .code-graph (always excluded)
    /// 2. .gitignore rules via the `gitignore` matcher (same source of truth as initial indexing)
    /// 3. Config file detection (tsconfig.json, package.json → ConfigChanged)
    /// 4. Source extension filter (.ts, .tsx, .js, .jsx)
    /// 5. File existence check (Modified vs Deleted)
    fn classify_event(path: &Path, project_root: &Path, gitignore: &Gitignore) -> Option<WatchEvent> {
        // Filter: skip node_modules (hardcoded, regardless of .gitignore — per CONTEXT.md)
        if path.components().any(|c| c.as_os_str() == "node_modules") {
            return None;
        }
        // Filter: skip .code-graph directory (our own cache writes)
        if path.components().any(|c| c.as_os_str() == ".code-graph") {
            return None;
        }

        // Filter: skip paths matching .gitignore rules (CONTEXT.md locked decision:
        // "Watcher respects same .gitignore rules used during initial indexing")
        let is_dir = path.is_dir();
        if gitignore.matched(path, is_dir).is_ignore() {
            return None;
        }

        // Check if it's a config file
        if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
            if CONFIG_FILES.contains(&file_name) {
                return Some(WatchEvent::ConfigChanged);
            }
        }

        // Check if it's a source file we care about
        let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
        if !SOURCE_EXTENSIONS.contains(&ext) {
            return None;
        }

        // Classify based on file existence
        if path.exists() {
            // File exists — could be Modified or Created.
            // notify-debouncer-mini doesn't distinguish; we treat both the same
            // in the incremental pipeline (remove old + re-parse).
            Some(WatchEvent::Modified(path.to_path_buf()))
        } else {
            Some(WatchEvent::Deleted(path.to_path_buf()))
        }
    }
    ```

    Note: classify_event uses file existence to distinguish Modified/Deleted. For Created events, the incremental handler (Plan 02 Task 2) treats Modified and Created identically: remove old entry if exists, then re-parse. This matches the CONTEXT.md decision that renames are treated as delete + create.

    Note on .gitignore compliance: The `ignore` crate is already a dependency (`ignore = "0.4"` in Cargo.toml). The `ignore::gitignore::Gitignore` struct provides the same matching logic used by `ignore::WalkBuilder` during initial indexing. The matcher is built once at watcher startup and passed into the bridge task by move — no per-event allocation or file I/O.
  </action>
  <verify>
    <automated>cd /workspace && cargo build 2>&1 | tail -5</automated>
    <manual>Verify watcher module compiles — notify and debouncer-mini resolve correctly</manual>
  </verify>
  <done>Watcher module exists with start_watcher returning WatcherHandle + tokio receiver. Events are debounced at 75ms, classified into WatchEvent variants. node_modules/.code-graph paths are hardcoded-filtered and .gitignore rules are applied via ignore::gitignore::Gitignore matcher (same source of truth as walker::walk_project). Compiles successfully.</done>
</task>

<task type="auto">
  <name>Task 2: Incremental re-index pipeline</name>
  <files>
    src/watcher/incremental.rs
  </files>
  <action>
    Implement the incremental graph update logic per CONTEXT.md decisions and research Pattern 3.

    **src/watcher/incremental.rs:**

    ```rust
    use std::path::{Path, PathBuf};
    use std::collections::HashMap;

    use petgraph::visit::EdgeRef;

    use crate::graph::CodeGraph;
    use crate::graph::edge::EdgeKind;
    use crate::graph::node::GraphNode;
    use crate::parser;
    use crate::resolver::{build_resolver, discover_workspace_packages, workspace_map_to_aliases, resolve_import, ResolutionOutcome};

    use super::event::WatchEvent;

    /// Handle a single watch event by performing an incremental graph update.
    ///
    /// For Modified/Created: removes old file entry, re-parses, re-adds to graph,
    /// re-resolves the file's imports, and checks if unresolved imports in other files
    /// now resolve to this file.
    ///
    /// For Deleted: removes the file from graph and marks imports pointing to it as unresolved.
    ///
    /// For ConfigChanged: triggers a full rebuild (caller handles this by calling build_graph).
    ///
    /// Returns `true` if the graph was modified, `false` if ConfigChanged (caller must full-rebuild).
    pub fn handle_file_event(
        graph: &mut CodeGraph,
        event: &WatchEvent,
        project_root: &Path,
    ) -> bool {
        match event {
            WatchEvent::Modified(path) | WatchEvent::Created(path) => {
                handle_modified(graph, path, project_root);
                true
            }
            WatchEvent::Deleted(path) => {
                handle_deleted(graph, path);
                true
            }
            WatchEvent::ConfigChanged => {
                // Caller must perform full rebuild
                false
            }
        }
    }

    /// Handle a modified or newly created file.
    fn handle_modified(graph: &mut CodeGraph, path: &Path, project_root: &Path) {
        // 1. Remove old entry if it exists
        graph.remove_file_from_graph(path);

        // 2. Read and parse the file
        let source = match std::fs::read(path) {
            Ok(s) => s,
            Err(_) => return, // file disappeared between event and handling
        };

        let language_str = match path.extension().and_then(|e| e.to_str()).unwrap_or("") {
            "ts" => "typescript",
            "tsx" => "tsx",
            "js" | "jsx" => "javascript",
            _ => return,
        };

        let result = match parser::parse_file(path, &source) {
            Ok(r) => r,
            Err(_) => return, // parse error — skip
        };

        // 3. Add file and symbols to graph
        let file_idx = graph.add_file(path.to_path_buf(), language_str);
        for (symbol, children) in &result.symbols {
            let sym_idx = graph.add_symbol(file_idx, symbol.clone());
            for child in children {
                graph.add_child_symbol(sym_idx, child.clone());
            }
        }

        // 4. Resolve this file's imports (scoped — not full resolve_all)
        let workspace_map = discover_workspace_packages(project_root);
        let aliases = workspace_map_to_aliases(&workspace_map);
        let resolver = build_resolver(project_root, aliases);

        for import in &result.imports {
            let specifier = &import.module_path;
            let outcome = resolve_import(&resolver, path, specifier);

            match outcome {
                ResolutionOutcome::Resolved(target_path) => {
                    if let Some(&target_idx) = graph.file_index.get(&target_path) {
                        graph.add_resolved_import(file_idx, target_idx, specifier);
                    }
                }
                ResolutionOutcome::BuiltinModule(_) => {
                    graph.add_unresolved_import(file_idx, specifier, "builtin");
                }
                ResolutionOutcome::Unresolved(_reason) => {
                    if is_external_package(specifier) {
                        let pkg_name = extract_package_name(specifier);
                        graph.add_external_package(file_idx, pkg_name, specifier);
                    } else {
                        graph.add_unresolved_import(file_idx, specifier, &_reason);
                    }
                }
            }
        }

        // 5. Wire symbol relationships for this file only
        wire_relationships_for_file(graph, &result.relationships, file_idx);

        // 6. Check if existing unresolved imports now resolve to this file
        fix_unresolved_pointing_to(graph, path, project_root);
    }

    /// Handle a deleted file.
    fn handle_deleted(graph: &mut CodeGraph, path: &Path) {
        // Find files that had ResolvedImport edges pointing to this file
        // BEFORE removing it, so we can mark those imports as unresolved.
        let file_idx = match graph.file_index.get(path).copied() {
            Some(idx) => idx,
            None => return, // not in graph
        };

        // Collect importers: files with ResolvedImport edges targeting this file
        let importers: Vec<(petgraph::stable_graph::NodeIndex, String)> = graph
            .graph
            .edges_directed(file_idx, petgraph::Direction::Incoming)
            .filter_map(|e| {
                if let EdgeKind::ResolvedImport { ref specifier } = e.weight() {
                    Some((e.source(), specifier.clone()))
                } else {
                    None
                }
            })
            .collect();

        // Remove the file and all its nodes/edges
        graph.remove_file_from_graph(path);

        // Mark importers' edges as unresolved (add UnresolvedImport nodes)
        for (importer_idx, specifier) in importers {
            graph.add_unresolved_import(importer_idx, &specifier, "target file deleted");
        }
    }

    /// Wire symbol relationships (Extends, Implements, Calls) for symbols in a single file.
    /// Adapted from resolver::resolve_all Step 5 but scoped to one file.
    fn wire_relationships_for_file(
        graph: &mut CodeGraph,
        relationships: &[crate::parser::relationships::RelationshipInfo],
        file_idx: petgraph::stable_graph::NodeIndex,
    ) {
        use crate::parser::relationships::RelationshipKind;

        for rel in relationships {
            match rel.kind {
                RelationshipKind::Extends
                | RelationshipKind::Implements
                | RelationshipKind::InterfaceExtends => {
                    let from_name = match &rel.from_name {
                        Some(n) => n,
                        None => continue,
                    };

                    let from_candidates =
                        graph.symbol_index.get(from_name).cloned().unwrap_or_default();
                    let to_candidates =
                        graph.symbol_index.get(&rel.to_name).cloned().unwrap_or_default();

                    if from_candidates.is_empty() || to_candidates.is_empty() {
                        continue;
                    }

                    let from_sym_idx = from_candidates
                        .iter()
                        .copied()
                        .find(|&idx| graph.graph.edges(file_idx).any(|e| e.target() == idx))
                        .unwrap_or(from_candidates[0]);

                    let same_file_to: Vec<_> = to_candidates
                        .iter()
                        .copied()
                        .filter(|&idx| graph.graph.edges(file_idx).any(|e| e.target() == idx))
                        .collect();

                    let to_indices = if same_file_to.is_empty() {
                        to_candidates
                    } else {
                        same_file_to
                    };

                    for to_sym_idx in to_indices {
                        match rel.kind {
                            RelationshipKind::Extends | RelationshipKind::InterfaceExtends => {
                                graph.add_extends_edge(from_sym_idx, to_sym_idx);
                            }
                            RelationshipKind::Implements => {
                                graph.add_implements_edge(from_sym_idx, to_sym_idx);
                            }
                            _ => unreachable!(),
                        }
                    }
                }

                RelationshipKind::Calls
                | RelationshipKind::MethodCall
                | RelationshipKind::TypeReference => {
                    let to_candidates = match graph.symbol_index.get(&rel.to_name) {
                        Some(c) if !c.is_empty() => c.clone(),
                        _ => continue,
                    };

                    if to_candidates.len() == 1 {
                        graph.add_calls_edge(file_idx, to_candidates[0]);
                    }
                }
            }
        }
    }

    /// After adding a new/modified file, check if any existing UnresolvedImport nodes
    /// in the graph might now resolve to this file. If so, remove the unresolved node
    /// and add a proper ResolvedImport edge.
    fn fix_unresolved_pointing_to(
        graph: &mut CodeGraph,
        new_file_path: &Path,
        project_root: &Path,
    ) {
        // Collect unresolved import nodes and their importers
        let unresolved: Vec<(petgraph::stable_graph::NodeIndex, petgraph::stable_graph::NodeIndex, String)> = graph
            .graph
            .node_indices()
            .filter_map(|idx| {
                if let GraphNode::UnresolvedImport { ref specifier, ref reason } = graph.graph[idx] {
                    if reason != "builtin" {
                        // Find the importer (the node with an edge to this unresolved node)
                        let importer = graph
                            .graph
                            .edges_directed(idx, petgraph::Direction::Incoming)
                            .next()
                            .map(|e| e.source());
                        if let Some(importer_idx) = importer {
                            return Some((idx, importer_idx, specifier.clone()));
                        }
                    }
                }
                None
            })
            .collect();

        if unresolved.is_empty() {
            return;
        }

        // Build resolver to check if unresolved specifiers now resolve to the new file
        let workspace_map = discover_workspace_packages(project_root);
        let aliases = workspace_map_to_aliases(&workspace_map);
        let resolver = build_resolver(project_root, aliases);

        let new_file_idx = match graph.file_index.get(new_file_path).copied() {
            Some(idx) => idx,
            None => return,
        };

        for (unresolved_idx, importer_idx, specifier) in unresolved {
            // Get importer's file path
            let importer_path = match &graph.graph[importer_idx] {
                GraphNode::File(info) => info.path.clone(),
                _ => continue,
            };

            let outcome = resolve_import(&resolver, &importer_path, &specifier);
            if let ResolutionOutcome::Resolved(resolved_path) = outcome {
                if resolved_path == new_file_path {
                    // This unresolved import now resolves to the new file!
                    graph.graph.remove_node(unresolved_idx);
                    graph.add_resolved_import(importer_idx, new_file_idx, &specifier);
                }
            }
        }
    }

    // Re-use the same helpers from resolver::mod.rs (these are private there, so duplicate)
    fn is_external_package(specifier: &str) -> bool {
        !specifier.starts_with('.') && !specifier.starts_with('/')
    }

    fn extract_package_name(specifier: &str) -> &str {
        if specifier.starts_with('@') {
            let parts: Vec<&str> = specifier.splitn(3, '/').collect();
            if parts.len() >= 2 {
                let scope_end = parts[0].len() + 1 + parts[1].len();
                &specifier[..scope_end]
            } else {
                specifier
            }
        } else {
            match specifier.find('/') {
                Some(idx) => &specifier[..idx],
                None => specifier,
            }
        }
    }
    ```

    Note on the duplicated `is_external_package` and `extract_package_name` helpers: these are private in `resolver/mod.rs`. Rather than changing their visibility (which would touch a Plan 01 file), duplicate them here. They are 15 lines total and stable. If desired, a future cleanup can make them `pub(crate)` in the resolver module.
  </action>
  <verify>
    <automated>cd /workspace && cargo build 2>&1 | tail -5</automated>
    <manual>Verify incremental module compiles — handle_file_event, handle_modified, handle_deleted all exist</manual>
  </verify>
  <done>Incremental re-index pipeline implemented. handle_file_event dispatches Modified/Created/Deleted/ConfigChanged. Modified handler removes old entry, re-parses, re-resolves (scoped to single file), wires relationships, and fixes newly-resolvable imports. Deleted handler removes file and marks dependents' imports as unresolved. Compiles successfully.</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with zero new errors
2. `cargo test` passes all existing tests plus any new tests
3. `start_watcher` returns WatcherHandle + tokio receiver
4. `classify_event` filters node_modules, .code-graph, and .gitignore'd paths; classifies config changes
5. `handle_file_event` dispatches to handle_modified/handle_deleted
6. `handle_modified` does remove + re-parse + scoped resolve + fix unresolved
7. `handle_deleted` removes file + marks dependents as unresolved
</verification>

<success_criteria>
- notify 8 and notify-debouncer-mini 0.7 added to Cargo.toml
- WatcherHandle struct keeps debouncer alive
- Events debounced at 75ms, classified into WatchEvent enum
- node_modules and .code-graph paths filtered (hardcoded)
- .gitignore rules applied in watcher event filter (same source of truth as initial indexing via ignore crate)
- Config file changes produce ConfigChanged variant
- Incremental re-index: remove old + re-parse + scoped resolve for Modified/Created
- File deletion: remove file + mark dependent imports as unresolved
- New file: check if existing unresolved imports now resolve
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-watch-mode-persistence/05-02-SUMMARY.md`
</output>
