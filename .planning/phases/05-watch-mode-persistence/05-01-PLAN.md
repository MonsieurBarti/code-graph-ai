---
phase: 05-watch-mode-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/graph/node.rs
  - src/graph/edge.rs
  - src/graph/mod.rs
  - src/cache/mod.rs
  - src/cache/envelope.rs
autonomous: true
requirements: [PERF-04]

must_haves:
  truths:
    - "All graph node and edge types derive Serialize + Deserialize"
    - "CodeGraph can be serialized to bincode and deserialized back identically"
    - "A file and all its symbols/edges can be surgically removed from CodeGraph"
    - "Cache envelope with version and mtime map can be written atomically and read back"
  artifacts:
    - path: "Cargo.toml"
      provides: "bincode 2, tempfile 3, petgraph serde-1 feature"
      contains: "bincode"
    - path: "src/graph/node.rs"
      provides: "Serde derives on GraphNode, SymbolInfo, FileInfo, etc."
      contains: "serde::Serialize"
    - path: "src/graph/edge.rs"
      provides: "Serde derives on EdgeKind"
      contains: "serde::Serialize"
    - path: "src/graph/mod.rs"
      provides: "Serde derives on CodeGraph + remove_file_from_graph method"
      contains: "remove_file_from_graph"
    - path: "src/cache/mod.rs"
      provides: "Cache module re-exports"
      contains: "pub mod envelope"
    - path: "src/cache/envelope.rs"
      provides: "CacheEnvelope struct, save_cache, load_cache functions"
      contains: "CacheEnvelope"
  key_links:
    - from: "src/cache/envelope.rs"
      to: "src/graph/mod.rs"
      via: "CacheEnvelope serializes CodeGraph via bincode + serde"
      pattern: "bincode::serde::encode_into_std_write"
    - from: "src/graph/mod.rs"
      to: "petgraph StableGraph"
      via: "serde-1 feature enables StableGraph serialization"
      pattern: "serde::Serialize.*serde::Deserialize"
---

<objective>
Add serialization support to the code graph and build the persistence cache layer.

Purpose: This is the foundation for both graph persistence (PERF-04) and incremental re-indexing. All graph types need serde derives before the graph can be cached to disk. The remove_file helper is needed by the watcher's incremental update logic. The cache envelope provides atomic save/load with versioning.

Output: Serializable graph types, remove_file_from_graph method on CodeGraph, cache save/load functions with bincode envelope.
</objective>

<execution_context>
@/Users/monsieurbarti/.claude/get-shit-done/workflows/execute-plan.md
@/Users/monsieurbarti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-watch-mode-persistence/05-RESEARCH.md
@.planning/phases/04-mcp-integration/04-02-SUMMARY.md
@src/graph/mod.rs
@src/graph/node.rs
@src/graph/edge.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add serde derives to graph types and dependencies</name>
  <files>
    Cargo.toml
    src/graph/node.rs
    src/graph/edge.rs
    src/graph/mod.rs
  </files>
  <action>
    Update Cargo.toml:
    - Change `petgraph` to: `petgraph = { version = "0.6", features = ["stable_graph", "serde-1"] }`
    - Add `bincode = { version = "2", features = ["serde"] }` (note: bincode 2 stable; do NOT add "derive" feature — we use the serde path only)
    - Add `tempfile = "3"`
    - serde already has `features = ["derive"]` — no change needed

    Add `#[derive(serde::Serialize, serde::Deserialize)]` to ALL types in:

    **src/graph/node.rs:**
    - `SymbolKind` enum — add `serde::Serialize, serde::Deserialize` to existing derive
    - `SymbolInfo` struct — add `serde::Serialize, serde::Deserialize`
    - `FileInfo` struct — add `serde::Serialize, serde::Deserialize`
    - `ExternalPackageInfo` struct — add `serde::Serialize, serde::Deserialize`
    - `GraphNode` enum — add `serde::Serialize, serde::Deserialize`

    **src/graph/edge.rs:**
    - `EdgeKind` enum — add `serde::Serialize, serde::Deserialize`

    **src/graph/mod.rs:**
    - Add `#[derive(serde::Serialize, serde::Deserialize)]` to `CodeGraph` struct

    Also add a `remove_file_from_graph` method to `CodeGraph`:
    ```rust
    /// Remove a file and all its owned nodes/edges from the graph.
    ///
    /// Removes: the file node, all Symbol nodes connected via Contains edges,
    /// all child symbols (via ChildOf edges from those symbols), and all edges
    /// to/from any of these nodes. Also cleans up file_index and symbol_index.
    pub fn remove_file_from_graph(&mut self, path: &Path) {
        let file_idx = match self.file_index.remove(path) {
            Some(idx) => idx,
            None => return, // file not in graph
        };

        // Collect symbol nodes owned by this file (Contains edges from file)
        let mut nodes_to_remove = vec![file_idx];
        let symbol_indices: Vec<NodeIndex> = self.graph
            .edges(file_idx)
            .filter(|e| matches!(e.weight(), EdgeKind::Contains))
            .map(|e| e.target())
            .collect();

        for &sym_idx in &symbol_indices {
            nodes_to_remove.push(sym_idx);
            // Also collect child symbols (ChildOf edges pointing TO this symbol)
            let children: Vec<NodeIndex> = self.graph
                .edges_directed(sym_idx, petgraph::Direction::Incoming)
                .filter(|e| matches!(e.weight(), EdgeKind::ChildOf))
                .map(|e| e.source())
                .collect();
            nodes_to_remove.extend(children);
        }

        // Clean up symbol_index for all symbol nodes being removed
        for &node_idx in &nodes_to_remove {
            if let Some(GraphNode::Symbol(ref info)) = self.graph.node_weight(node_idx) {
                let name = info.name.clone();
                if let Some(indices) = self.symbol_index.get_mut(&name) {
                    indices.retain(|&i| i != node_idx);
                    if indices.is_empty() {
                        self.symbol_index.remove(&name);
                    }
                }
            }
        }

        // Remove all nodes (StableGraph removes associated edges automatically)
        for node_idx in nodes_to_remove {
            self.graph.remove_node(node_idx);
        }
    }
    ```

    Import `use std::path::Path;` and `use petgraph::visit::EdgeRef;` at the top of mod.rs if not already present.
    Import `use petgraph::Direction;` if needed for `edges_directed`.
  </action>
  <verify>
    <automated>cd /workspace && cargo build 2>&1 | tail -5</automated>
    <manual>Verify serde derives compile cleanly with petgraph serde-1 feature</manual>
  </verify>
  <done>All graph types have Serialize + Deserialize derives. petgraph serde-1 feature enabled. bincode and tempfile dependencies added. remove_file_from_graph method exists on CodeGraph. cargo build succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Implement cache envelope with atomic save/load</name>
  <files>
    src/cache/mod.rs
    src/cache/envelope.rs
    src/main.rs
  </files>
  <action>
    Create `src/cache/` module:

    **src/cache/mod.rs:**
    ```rust
    pub mod envelope;
    pub use envelope::{save_cache, load_cache, CacheEnvelope};
    ```

    **src/cache/envelope.rs:**
    Implement the persistence envelope per research Pattern 4:

    ```rust
    use std::collections::HashMap;
    use std::path::{Path, PathBuf};
    use std::io::Write;

    use crate::graph::CodeGraph;

    /// Current cache format version. Bump when graph struct layout changes.
    pub const CACHE_VERSION: u32 = 1;

    /// Cache directory name (created in project root).
    pub const CACHE_DIR: &str = ".code-graph";
    /// Cache file name within CACHE_DIR.
    pub const CACHE_FILE: &str = "graph.bin";

    /// Metadata for a cached file: mtime (seconds since epoch) + file size.
    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FileMeta {
        pub mtime_secs: u64,
        pub size: u64,
    }

    /// Envelope wrapping the serialized graph with version and staleness metadata.
    #[derive(serde::Serialize, serde::Deserialize)]
    pub struct CacheEnvelope {
        pub version: u32,
        pub project_root: PathBuf,
        pub file_mtimes: HashMap<PathBuf, FileMeta>,
        pub graph: CodeGraph,
    }

    /// Build the cache file path for a project: `<project_root>/.code-graph/graph.bin`
    pub fn cache_path(project_root: &Path) -> PathBuf {
        project_root.join(CACHE_DIR).join(CACHE_FILE)
    }

    /// Collect current filesystem metadata (mtime + size) for all files in the graph.
    pub fn collect_file_mtimes(graph: &CodeGraph) -> HashMap<PathBuf, FileMeta> {
        let mut mtimes = HashMap::new();
        for path in graph.file_index.keys() {
            if let Ok(metadata) = std::fs::metadata(path) {
                let mtime_secs = metadata
                    .modified()
                    .ok()
                    .and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok())
                    .map(|d| d.as_secs())
                    .unwrap_or(0);
                mtimes.insert(
                    path.clone(),
                    FileMeta {
                        mtime_secs,
                        size: metadata.len(),
                    },
                );
            }
        }
        mtimes
    }

    /// Save the graph to disk atomically using bincode serialization.
    ///
    /// Writes to a temp file first, then renames to the final path.
    /// Creates the `.code-graph/` directory if it doesn't exist.
    pub fn save_cache(project_root: &Path, graph: &CodeGraph) -> anyhow::Result<()> {
        let cache_dir = project_root.join(CACHE_DIR);
        std::fs::create_dir_all(&cache_dir)?;

        let file_mtimes = collect_file_mtimes(graph);
        let envelope = CacheEnvelope {
            version: CACHE_VERSION,
            project_root: project_root.to_path_buf(),
            file_mtimes,
            graph: graph.clone(),
        };

        // Atomic write: temp file in same directory, then rename
        let target = cache_path(project_root);
        let mut tmp = tempfile::NamedTempFile::new_in(&cache_dir)?;
        bincode::serde::encode_into_std_write(&envelope, &mut tmp, bincode::config::standard())?;
        tmp.as_file().flush()?;
        tmp.persist(&target)?;

        Ok(())
    }

    /// Load the cached graph from disk. Returns None if:
    /// - Cache file doesn't exist
    /// - Cache version doesn't match CACHE_VERSION
    /// - Deserialization fails (corrupt cache)
    pub fn load_cache(project_root: &Path) -> Option<CacheEnvelope> {
        let target = cache_path(project_root);
        let bytes = std::fs::read(&target).ok()?;
        let result = bincode::serde::decode_from_slice::<CacheEnvelope, _>(
            &bytes,
            bincode::config::standard(),
        );
        match result {
            Ok((envelope, _)) if envelope.version == CACHE_VERSION => Some(envelope),
            _ => None, // version mismatch or corrupt — caller will do full rebuild
        }
    }
    ```

    **src/main.rs:**
    - Add `mod cache;` declaration alongside the other mod declarations (after `mod graph;`).

    The CodeGraph struct needs `Clone` derive for the `graph.clone()` call in save_cache.
    Add `Clone` to CodeGraph's derive in `src/graph/mod.rs` if not already present.
    Note: `StableGraph` implements Clone when node/edge types do (they already have Clone).
    `HashMap` implements Clone. So CodeGraph can derive Clone.

    Add a unit test in `src/cache/envelope.rs`:
    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::graph::node::{SymbolInfo, SymbolKind};

        #[test]
        fn test_roundtrip_cache() {
            let mut graph = CodeGraph::new();
            let tmp_dir = tempfile::tempdir().unwrap();
            let fake_file = tmp_dir.path().join("test.ts");
            std::fs::write(&fake_file, "// test").unwrap();

            let f = graph.add_file(fake_file.clone(), "typescript");
            graph.add_symbol(
                f,
                SymbolInfo {
                    name: "hello".into(),
                    kind: SymbolKind::Function,
                    line: 1,
                    col: 0,
                    is_exported: true,
                    is_default: false,
                },
            );

            // Save
            save_cache(tmp_dir.path(), &graph).unwrap();

            // Load
            let loaded = load_cache(tmp_dir.path()).expect("cache should load");
            assert_eq!(loaded.version, CACHE_VERSION);
            assert_eq!(loaded.graph.file_count(), 1);
            assert_eq!(loaded.graph.symbol_count(), 1);
            assert!(loaded.file_mtimes.contains_key(&fake_file));
        }

        #[test]
        fn test_load_missing_cache_returns_none() {
            let tmp_dir = tempfile::tempdir().unwrap();
            assert!(load_cache(tmp_dir.path()).is_none());
        }
    }
    ```
  </action>
  <verify>
    <automated>cd /workspace && cargo test -- cache 2>&1 | tail -10</automated>
    <manual>Verify cache roundtrip test passes — graph serializes and deserializes correctly</manual>
  </verify>
  <done>Cache module exists with CacheEnvelope, save_cache, and load_cache. Roundtrip test passes (graph serializes to bincode and deserializes back with correct file/symbol counts). CodeGraph derives Clone. mod cache declared in main.rs.</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with zero new errors
2. `cargo test` passes all existing tests (87+) plus new cache roundtrip tests
3. All graph types in node.rs, edge.rs, mod.rs have Serialize + Deserialize derives
4. `remove_file_from_graph` method exists on CodeGraph
5. `save_cache` / `load_cache` functions exist and handle atomic writes
</verification>

<success_criteria>
- petgraph serde-1 feature enabled in Cargo.toml
- bincode 2 and tempfile 3 added to Cargo.toml
- All GraphNode variants, EdgeKind, SymbolInfo, FileInfo, ExternalPackageInfo derive Serialize + Deserialize
- CodeGraph derives Serialize, Deserialize, Clone
- remove_file_from_graph method surgically removes a file + its symbols + cleans indexes
- CacheEnvelope with CACHE_VERSION, save_cache (atomic), load_cache (version-checked)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-watch-mode-persistence/05-01-SUMMARY.md`
</output>
